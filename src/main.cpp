/*** Compiler Front-End Test automatically generated by the BNF Converter ***/
/*                                                                          */
/* This test will parse a file, print the abstract syntax tree, and then    */
/* pretty-print the result.                                                 */
/*                                                                          */
/****************************************************************************/
#include <iostream>
#include <string.h>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"

void usage() {
  /*printf("usage: Call with one of the following argument combinations:\n");
  printf("\t--help\t\tDisplay this help message.\n");
  printf("\t(no arguments)	Parse stdin verbosely.\n");
  printf("\t(files)\t\tParse content of files verbosely.\n");
  printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");*/
}

int main(int argc, char ** argv)
{	
	std::cout << "Welcome to Roller"<< std::endl;
	std::cout << "Developed by mrZalli (https://github.com/mrZalli)" << std::endl;
	std::cout << "!quit or !q to quit" << std::endl << std::endl;
	
	const String prompt = "> ";
	
	while (true) {
		String command;
		std::cout << prompt;
		std::getline(std::cin, command);
		
		if (command == "!q" || command == "!quit") {
			std::cout << "Quitting" << std::endl;
			return 0;
		}
		
		Cmd* parse_tree = pCmd(command.c_str());
		
		if (parse_tree) {
			std::cout << std::endl << "[Abstract Syntax]" << std::endl;
	        ShowAbsyn *s = new ShowAbsyn();
	        std::cout << s->show(parse_tree) << std::endl << std::endl;
	        std::cout << "[Linearized Tree]" << std::endl;
	        PrintAbsyn *p = new PrintAbsyn();
			std::cout << p->print(parse_tree) << std::endl << std::endl;
		}
		else {
			std::cout << "Parse unsuccesful" << std::endl;
		}
	}
  
  return 1;
}

