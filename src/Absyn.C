//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   ExpCmd    ********************/
ExpCmd::ExpCmd(Exp *p1)
{
  exp_ = p1;

}

ExpCmd::ExpCmd(const ExpCmd & other)
{
  exp_ = other.exp_->clone();

}

ExpCmd &ExpCmd::operator=(const ExpCmd & other)
{
  ExpCmd tmp(other);
  swap(tmp);
  return *this;
}

void ExpCmd::swap(ExpCmd & other)
{
  std::swap(exp_, other.exp_);

}

ExpCmd::~ExpCmd()
{
  delete(exp_);

}

void ExpCmd::accept(Visitor *v)
{
  v->visitExpCmd(this);
}

ExpCmd *ExpCmd::clone() const
{
  return new ExpCmd(*this);
}



/********************   StmtCmd    ********************/
StmtCmd::StmtCmd(Stmt *p1)
{
  stmt_ = p1;

}

StmtCmd::StmtCmd(const StmtCmd & other)
{
  stmt_ = other.stmt_->clone();

}

StmtCmd &StmtCmd::operator=(const StmtCmd & other)
{
  StmtCmd tmp(other);
  swap(tmp);
  return *this;
}

void StmtCmd::swap(StmtCmd & other)
{
  std::swap(stmt_, other.stmt_);

}

StmtCmd::~StmtCmd()
{
  delete(stmt_);

}

void StmtCmd::accept(Visitor *v)
{
  v->visitStmtCmd(this);
}

StmtCmd *StmtCmd::clone() const
{
  return new StmtCmd(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   ERange    ********************/
ERange::ERange(Val *p1, Val *p2)
{
  val_1 = p1;
  val_2 = p2;

}

ERange::ERange(const ERange & other)
{
  val_1 = other.val_1->clone();
  val_2 = other.val_2->clone();

}

ERange &ERange::operator=(const ERange & other)
{
  ERange tmp(other);
  swap(tmp);
  return *this;
}

void ERange::swap(ERange & other)
{
  std::swap(val_1, other.val_1);
  std::swap(val_2, other.val_2);

}

ERange::~ERange()
{
  delete(val_1);
  delete(val_2);

}

void ERange::accept(Visitor *v)
{
  v->visitERange(this);
}

ERange *ERange::clone() const
{
  return new ERange(*this);
}



/********************   ERStep    ********************/
ERStep::ERStep(Val *p1, Val *p2, Val *p3)
{
  val_1 = p1;
  val_2 = p2;
  val_3 = p3;

}

ERStep::ERStep(const ERStep & other)
{
  val_1 = other.val_1->clone();
  val_2 = other.val_2->clone();
  val_3 = other.val_3->clone();

}

ERStep &ERStep::operator=(const ERStep & other)
{
  ERStep tmp(other);
  swap(tmp);
  return *this;
}

void ERStep::swap(ERStep & other)
{
  std::swap(val_1, other.val_1);
  std::swap(val_2, other.val_2);
  std::swap(val_3, other.val_3);

}

ERStep::~ERStep()
{
  delete(val_1);
  delete(val_2);
  delete(val_3);

}

void ERStep::accept(Visitor *v)
{
  v->visitERStep(this);
}

ERStep *ERStep::clone() const
{
  return new ERStep(*this);
}



/********************   EList    ********************/
EList::EList(ListListMem *p1)
{
  listlistmem_ = p1;

}

EList::EList(const EList & other)
{
  listlistmem_ = other.listlistmem_->clone();

}

EList &EList::operator=(const EList & other)
{
  EList tmp(other);
  swap(tmp);
  return *this;
}

void EList::swap(EList & other)
{
  std::swap(listlistmem_, other.listlistmem_);

}

EList::~EList()
{
  delete(listlistmem_);

}

void EList::accept(Visitor *v)
{
  v->visitEList(this);
}

EList *EList::clone() const
{
  return new EList(*this);
}



/********************   EDice    ********************/
EDice::EDice(ExpD *p1)
{
  expd_ = p1;

}

EDice::EDice(const EDice & other)
{
  expd_ = other.expd_->clone();

}

EDice &EDice::operator=(const EDice & other)
{
  EDice tmp(other);
  swap(tmp);
  return *this;
}

void EDice::swap(EDice & other)
{
  std::swap(expd_, other.expd_);

}

EDice::~EDice()
{
  delete(expd_);

}

void EDice::accept(Visitor *v)
{
  v->visitEDice(this);
}

EDice *EDice::clone() const
{
  return new EDice(*this);
}



/********************   EKeyW    ********************/
EKeyW::EKeyW(ExpKW *p1)
{
  expkw_ = p1;

}

EKeyW::EKeyW(const EKeyW & other)
{
  expkw_ = other.expkw_->clone();

}

EKeyW &EKeyW::operator=(const EKeyW & other)
{
  EKeyW tmp(other);
  swap(tmp);
  return *this;
}

void EKeyW::swap(EKeyW & other)
{
  std::swap(expkw_, other.expkw_);

}

EKeyW::~EKeyW()
{
  delete(expkw_);

}

void EKeyW::accept(Visitor *v)
{
  v->visitEKeyW(this);
}

EKeyW *EKeyW::clone() const
{
  return new EKeyW(*this);
}



/********************   EListOp    ********************/
EListOp::EListOp(ExpLOp *p1)
{
  explop_ = p1;

}

EListOp::EListOp(const EListOp & other)
{
  explop_ = other.explop_->clone();

}

EListOp &EListOp::operator=(const EListOp & other)
{
  EListOp tmp(other);
  swap(tmp);
  return *this;
}

void EListOp::swap(EListOp & other)
{
  std::swap(explop_, other.explop_);

}

EListOp::~EListOp()
{
  delete(explop_);

}

void EListOp::accept(Visitor *v)
{
  v->visitEListOp(this);
}

EListOp *EListOp::clone() const
{
  return new EListOp(*this);
}



/********************   EVar    ********************/
EVar::EVar(VarIdent p1)
{
  varident_ = p1;

}

EVar::EVar(const EVar & other)
{
  varident_ = other.varident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(varident_, other.varident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   ECall    ********************/
ECall::ECall(VarIdent p1, ListExp *p2)
{
  varident_ = p1;
  listexp_ = p2;

}

ECall::ECall(const ECall & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();

}

ECall &ECall::operator=(const ECall & other)
{
  ECall tmp(other);
  swap(tmp);
  return *this;
}

void ECall::swap(ECall & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);

}

ECall::~ECall()
{
  delete(listexp_);

}

void ECall::accept(Visitor *v)
{
  v->visitECall(this);
}

ECall *ECall::clone() const
{
  return new ECall(*this);
}



/********************   E1d6    ********************/
E1d6::E1d6()
{

}

E1d6::E1d6(const E1d6 & other)
{

}

E1d6 &E1d6::operator=(const E1d6 & other)
{
  E1d6 tmp(other);
  swap(tmp);
  return *this;
}

void E1d6::swap(E1d6 & other)
{

}

E1d6::~E1d6()
{

}

void E1d6::accept(Visitor *v)
{
  v->visitE1d6(this);
}

E1d6 *E1d6::clone() const
{
  return new E1d6(*this);
}



/********************   E1dN    ********************/
E1dN::E1dN(Exp *p1)
{
  exp_ = p1;

}

E1dN::E1dN(const E1dN & other)
{
  exp_ = other.exp_->clone();

}

E1dN &E1dN::operator=(const E1dN & other)
{
  E1dN tmp(other);
  swap(tmp);
  return *this;
}

void E1dN::swap(E1dN & other)
{
  std::swap(exp_, other.exp_);

}

E1dN::~E1dN()
{
  delete(exp_);

}

void E1dN::accept(Visitor *v)
{
  v->visitE1dN(this);
}

E1dN *E1dN::clone() const
{
  return new E1dN(*this);
}



/********************   ENd6    ********************/
ENd6::ENd6(Exp *p1)
{
  exp_ = p1;

}

ENd6::ENd6(const ENd6 & other)
{
  exp_ = other.exp_->clone();

}

ENd6 &ENd6::operator=(const ENd6 & other)
{
  ENd6 tmp(other);
  swap(tmp);
  return *this;
}

void ENd6::swap(ENd6 & other)
{
  std::swap(exp_, other.exp_);

}

ENd6::~ENd6()
{
  delete(exp_);

}

void ENd6::accept(Visitor *v)
{
  v->visitENd6(this);
}

ENd6 *ENd6::clone() const
{
  return new ENd6(*this);
}



/********************   ENdN    ********************/
ENdN::ENdN(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENdN::ENdN(const ENdN & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENdN &ENdN::operator=(const ENdN & other)
{
  ENdN tmp(other);
  swap(tmp);
  return *this;
}

void ENdN::swap(ENdN & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENdN::~ENdN()
{
  delete(exp_1);
  delete(exp_2);

}

void ENdN::accept(Visitor *v)
{
  v->visitENdN(this);
}

ENdN *ENdN::clone() const
{
  return new ENdN(*this);
}



/********************   EKCount    ********************/
EKCount::EKCount(Exp *p1)
{
  exp_ = p1;

}

EKCount::EKCount(const EKCount & other)
{
  exp_ = other.exp_->clone();

}

EKCount &EKCount::operator=(const EKCount & other)
{
  EKCount tmp(other);
  swap(tmp);
  return *this;
}

void EKCount::swap(EKCount & other)
{
  std::swap(exp_, other.exp_);

}

EKCount::~EKCount()
{
  delete(exp_);

}

void EKCount::accept(Visitor *v)
{
  v->visitEKCount(this);
}

EKCount *EKCount::clone() const
{
  return new EKCount(*this);
}



/********************   EKSum    ********************/
EKSum::EKSum(Exp *p1)
{
  exp_ = p1;

}

EKSum::EKSum(const EKSum & other)
{
  exp_ = other.exp_->clone();

}

EKSum &EKSum::operator=(const EKSum & other)
{
  EKSum tmp(other);
  swap(tmp);
  return *this;
}

void EKSum::swap(EKSum & other)
{
  std::swap(exp_, other.exp_);

}

EKSum::~EKSum()
{
  delete(exp_);

}

void EKSum::accept(Visitor *v)
{
  v->visitEKSum(this);
}

EKSum *EKSum::clone() const
{
  return new EKSum(*this);
}



/********************   EKRepeat    ********************/
EKRepeat::EKRepeat(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EKRepeat::EKRepeat(const EKRepeat & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EKRepeat &EKRepeat::operator=(const EKRepeat & other)
{
  EKRepeat tmp(other);
  swap(tmp);
  return *this;
}

void EKRepeat::swap(EKRepeat & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EKRepeat::~EKRepeat()
{
  delete(exp_1);
  delete(exp_2);

}

void EKRepeat::accept(Visitor *v)
{
  v->visitEKRepeat(this);
}

EKRepeat *EKRepeat::clone() const
{
  return new EKRepeat(*this);
}



/********************   EKMean    ********************/
EKMean::EKMean(Exp *p1)
{
  exp_ = p1;

}

EKMean::EKMean(const EKMean & other)
{
  exp_ = other.exp_->clone();

}

EKMean &EKMean::operator=(const EKMean & other)
{
  EKMean tmp(other);
  swap(tmp);
  return *this;
}

void EKMean::swap(EKMean & other)
{
  std::swap(exp_, other.exp_);

}

EKMean::~EKMean()
{
  delete(exp_);

}

void EKMean::accept(Visitor *v)
{
  v->visitEKMean(this);
}

EKMean *EKMean::clone() const
{
  return new EKMean(*this);
}



/********************   PredBranch    ********************/
PredBranch::PredBranch(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredBranch::PredBranch(const PredBranch & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredBranch &PredBranch::operator=(const PredBranch & other)
{
  PredBranch tmp(other);
  swap(tmp);
  return *this;
}

void PredBranch::swap(PredBranch & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredBranch::~PredBranch()
{
  delete(pred_1);
  delete(pred_2);

}

void PredBranch::accept(Visitor *v)
{
  v->visitPredBranch(this);
}

PredBranch *PredBranch::clone() const
{
  return new PredBranch(*this);
}



/********************   PredAnd    ********************/
PredAnd::PredAnd(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredAnd::PredAnd(const PredAnd & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredAnd &PredAnd::operator=(const PredAnd & other)
{
  PredAnd tmp(other);
  swap(tmp);
  return *this;
}

void PredAnd::swap(PredAnd & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredAnd::~PredAnd()
{
  delete(pred_1);
  delete(pred_2);

}

void PredAnd::accept(Visitor *v)
{
  v->visitPredAnd(this);
}

PredAnd *PredAnd::clone() const
{
  return new PredAnd(*this);
}



/********************   PredOr    ********************/
PredOr::PredOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredOr::PredOr(const PredOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredOr &PredOr::operator=(const PredOr & other)
{
  PredOr tmp(other);
  swap(tmp);
  return *this;
}

void PredOr::swap(PredOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredOr::~PredOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredOr::accept(Visitor *v)
{
  v->visitPredOr(this);
}

PredOr *PredOr::clone() const
{
  return new PredOr(*this);
}



/********************   PredXOr    ********************/
PredXOr::PredXOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredXOr::PredXOr(const PredXOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredXOr &PredXOr::operator=(const PredXOr & other)
{
  PredXOr tmp(other);
  swap(tmp);
  return *this;
}

void PredXOr::swap(PredXOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredXOr::~PredXOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredXOr::accept(Visitor *v)
{
  v->visitPredXOr(this);
}

PredXOr *PredXOr::clone() const
{
  return new PredXOr(*this);
}



/********************   PredEQ    ********************/
PredEQ::PredEQ(Val *p1)
{
  val_ = p1;

}

PredEQ::PredEQ(const PredEQ & other)
{
  val_ = other.val_->clone();

}

PredEQ &PredEQ::operator=(const PredEQ & other)
{
  PredEQ tmp(other);
  swap(tmp);
  return *this;
}

void PredEQ::swap(PredEQ & other)
{
  std::swap(val_, other.val_);

}

PredEQ::~PredEQ()
{
  delete(val_);

}

void PredEQ::accept(Visitor *v)
{
  v->visitPredEQ(this);
}

PredEQ *PredEQ::clone() const
{
  return new PredEQ(*this);
}



/********************   PredNEQ    ********************/
PredNEQ::PredNEQ(Val *p1)
{
  val_ = p1;

}

PredNEQ::PredNEQ(const PredNEQ & other)
{
  val_ = other.val_->clone();

}

PredNEQ &PredNEQ::operator=(const PredNEQ & other)
{
  PredNEQ tmp(other);
  swap(tmp);
  return *this;
}

void PredNEQ::swap(PredNEQ & other)
{
  std::swap(val_, other.val_);

}

PredNEQ::~PredNEQ()
{
  delete(val_);

}

void PredNEQ::accept(Visitor *v)
{
  v->visitPredNEQ(this);
}

PredNEQ *PredNEQ::clone() const
{
  return new PredNEQ(*this);
}



/********************   PredGT    ********************/
PredGT::PredGT(Val *p1)
{
  val_ = p1;

}

PredGT::PredGT(const PredGT & other)
{
  val_ = other.val_->clone();

}

PredGT &PredGT::operator=(const PredGT & other)
{
  PredGT tmp(other);
  swap(tmp);
  return *this;
}

void PredGT::swap(PredGT & other)
{
  std::swap(val_, other.val_);

}

PredGT::~PredGT()
{
  delete(val_);

}

void PredGT::accept(Visitor *v)
{
  v->visitPredGT(this);
}

PredGT *PredGT::clone() const
{
  return new PredGT(*this);
}



/********************   PredLT    ********************/
PredLT::PredLT(Val *p1)
{
  val_ = p1;

}

PredLT::PredLT(const PredLT & other)
{
  val_ = other.val_->clone();

}

PredLT &PredLT::operator=(const PredLT & other)
{
  PredLT tmp(other);
  swap(tmp);
  return *this;
}

void PredLT::swap(PredLT & other)
{
  std::swap(val_, other.val_);

}

PredLT::~PredLT()
{
  delete(val_);

}

void PredLT::accept(Visitor *v)
{
  v->visitPredLT(this);
}

PredLT *PredLT::clone() const
{
  return new PredLT(*this);
}



/********************   PredGTEq    ********************/
PredGTEq::PredGTEq(Val *p1)
{
  val_ = p1;

}

PredGTEq::PredGTEq(const PredGTEq & other)
{
  val_ = other.val_->clone();

}

PredGTEq &PredGTEq::operator=(const PredGTEq & other)
{
  PredGTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredGTEq::swap(PredGTEq & other)
{
  std::swap(val_, other.val_);

}

PredGTEq::~PredGTEq()
{
  delete(val_);

}

void PredGTEq::accept(Visitor *v)
{
  v->visitPredGTEq(this);
}

PredGTEq *PredGTEq::clone() const
{
  return new PredGTEq(*this);
}



/********************   PredLTEq    ********************/
PredLTEq::PredLTEq(Val *p1)
{
  val_ = p1;

}

PredLTEq::PredLTEq(const PredLTEq & other)
{
  val_ = other.val_->clone();

}

PredLTEq &PredLTEq::operator=(const PredLTEq & other)
{
  PredLTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredLTEq::swap(PredLTEq & other)
{
  std::swap(val_, other.val_);

}

PredLTEq::~PredLTEq()
{
  delete(val_);

}

void PredLTEq::accept(Visitor *v)
{
  v->visitPredLTEq(this);
}

PredLTEq *PredLTEq::clone() const
{
  return new PredLTEq(*this);
}



/********************   ELFilt    ********************/
ELFilt::ELFilt(Exp *p1, Pred *p2)
{
  exp_ = p1;
  pred_ = p2;

}

ELFilt::ELFilt(const ELFilt & other)
{
  exp_ = other.exp_->clone();
  pred_ = other.pred_->clone();

}

ELFilt &ELFilt::operator=(const ELFilt & other)
{
  ELFilt tmp(other);
  swap(tmp);
  return *this;
}

void ELFilt::swap(ELFilt & other)
{
  std::swap(exp_, other.exp_);
  std::swap(pred_, other.pred_);

}

ELFilt::~ELFilt()
{
  delete(exp_);
  delete(pred_);

}

void ELFilt::accept(Visitor *v)
{
  v->visitELFilt(this);
}

ELFilt *ELFilt::clone() const
{
  return new ELFilt(*this);
}



/********************   ELSum    ********************/
ELSum::ELSum(Exp *p1)
{
  exp_ = p1;

}

ELSum::ELSum(const ELSum & other)
{
  exp_ = other.exp_->clone();

}

ELSum &ELSum::operator=(const ELSum & other)
{
  ELSum tmp(other);
  swap(tmp);
  return *this;
}

void ELSum::swap(ELSum & other)
{
  std::swap(exp_, other.exp_);

}

ELSum::~ELSum()
{
  delete(exp_);

}

void ELSum::accept(Visitor *v)
{
  v->visitELSum(this);
}

ELSum *ELSum::clone() const
{
  return new ELSum(*this);
}



/********************   ELAcc    ********************/
ELAcc::ELAcc(Exp *p1, VarIdent p2)
{
  exp_ = p1;
  varident_ = p2;

}

ELAcc::ELAcc(const ELAcc & other)
{
  exp_ = other.exp_->clone();
  varident_ = other.varident_;

}

ELAcc &ELAcc::operator=(const ELAcc & other)
{
  ELAcc tmp(other);
  swap(tmp);
  return *this;
}

void ELAcc::swap(ELAcc & other)
{
  std::swap(exp_, other.exp_);
  std::swap(varident_, other.varident_);

}

ELAcc::~ELAcc()
{
  delete(exp_);

}

void ELAcc::accept(Visitor *v)
{
  v->visitELAcc(this);
}

ELAcc *ELAcc::clone() const
{
  return new ELAcc(*this);
}



/********************   SVarAs    ********************/
SVarAs::SVarAs(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarAs::SVarAs(const SVarAs & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarAs &SVarAs::operator=(const SVarAs & other)
{
  SVarAs tmp(other);
  swap(tmp);
  return *this;
}

void SVarAs::swap(SVarAs & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarAs::~SVarAs()
{
  delete(exp_);

}

void SVarAs::accept(Visitor *v)
{
  v->visitSVarAs(this);
}

SVarAs *SVarAs::clone() const
{
  return new SVarAs(*this);
}



/********************   SFDef    ********************/
SFDef::SFDef(VarIdent p1, ListExp *p2, Exp *p3)
{
  varident_ = p1;
  listexp_ = p2;
  exp_ = p3;

}

SFDef::SFDef(const SFDef & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();
  exp_ = other.exp_->clone();

}

SFDef &SFDef::operator=(const SFDef & other)
{
  SFDef tmp(other);
  swap(tmp);
  return *this;
}

void SFDef::swap(SFDef & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);
  std::swap(exp_, other.exp_);

}

SFDef::~SFDef()
{
  delete(listexp_);
  delete(exp_);

}

void SFDef::accept(Visitor *v)
{
  v->visitSFDef(this);
}

SFDef *SFDef::clone() const
{
  return new SFDef(*this);
}



/********************   IntVal    ********************/
IntVal::IntVal(Integer p1)
{
  integer_ = p1;

}

IntVal::IntVal(const IntVal & other)
{
  integer_ = other.integer_;

}

IntVal &IntVal::operator=(const IntVal & other)
{
  IntVal tmp(other);
  swap(tmp);
  return *this;
}

void IntVal::swap(IntVal & other)
{
  std::swap(integer_, other.integer_);

}

IntVal::~IntVal()
{

}

void IntVal::accept(Visitor *v)
{
  v->visitIntVal(this);
}

IntVal *IntVal::clone() const
{
  return new IntVal(*this);
}



/********************   IntNegVal    ********************/
IntNegVal::IntNegVal(Integer p1)
{
  integer_ = p1;

}

IntNegVal::IntNegVal(const IntNegVal & other)
{
  integer_ = other.integer_;

}

IntNegVal &IntNegVal::operator=(const IntNegVal & other)
{
  IntNegVal tmp(other);
  swap(tmp);
  return *this;
}

void IntNegVal::swap(IntNegVal & other)
{
  std::swap(integer_, other.integer_);

}

IntNegVal::~IntNegVal()
{

}

void IntNegVal::accept(Visitor *v)
{
  v->visitIntNegVal(this);
}

IntNegVal *IntNegVal::clone() const
{
  return new IntNegVal(*this);
}



/********************   VarVal    ********************/
VarVal::VarVal(VarIdent p1)
{
  varident_ = p1;

}

VarVal::VarVal(const VarVal & other)
{
  varident_ = other.varident_;

}

VarVal &VarVal::operator=(const VarVal & other)
{
  VarVal tmp(other);
  swap(tmp);
  return *this;
}

void VarVal::swap(VarVal & other)
{
  std::swap(varident_, other.varident_);

}

VarVal::~VarVal()
{

}

void VarVal::accept(Visitor *v)
{
  v->visitVarVal(this);
}

VarVal *VarVal::clone() const
{
  return new VarVal(*this);
}



/********************   ValLM    ********************/
ValLM::ValLM(Val *p1)
{
  val_ = p1;

}

ValLM::ValLM(const ValLM & other)
{
  val_ = other.val_->clone();

}

ValLM &ValLM::operator=(const ValLM & other)
{
  ValLM tmp(other);
  swap(tmp);
  return *this;
}

void ValLM::swap(ValLM & other)
{
  std::swap(val_, other.val_);

}

ValLM::~ValLM()
{
  delete(val_);

}

void ValLM::accept(Visitor *v)
{
  v->visitValLM(this);
}

ValLM *ValLM::clone() const
{
  return new ValLM(*this);
}



/********************   StrLM    ********************/
StrLM::StrLM(String p1)
{
  string_ = p1;

}

StrLM::StrLM(const StrLM & other)
{
  string_ = other.string_;

}

StrLM &StrLM::operator=(const StrLM & other)
{
  StrLM tmp(other);
  swap(tmp);
  return *this;
}

void StrLM::swap(StrLM & other)
{
  std::swap(string_, other.string_);

}

StrLM::~StrLM()
{

}

void StrLM::accept(Visitor *v)
{
  v->visitStrLM(this);
}

StrLM *StrLM::clone() const
{
  return new StrLM(*this);
}




/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListListMem    ********************/

void ListListMem::accept(Visitor *v)
{
  v->visitListListMem(this);
}


ListListMem *ListListMem::clone() const
{
  return new ListListMem(*this);
}




