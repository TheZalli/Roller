#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string VarIdent;


/********************   Forward Declarations    ********************/

class Cmd;
class Exp;
class Numeral;
class Val;
class ExpSeq;
class ExpD;
class ExpKW;
class Pred;
class Stmt;
class ExpCmd;
class StmtCmd;
class EAdd;
class ESub;
class EMul;
class EDiv;
class IntNum;
class IntNegNum;
class EVal;
class ValNum;
class ValVar;
class ValStr;
class ESeq;
class ERange;
class ERStep;
class EVect;
class EDice;
class E1d6;
class E1dN;
class ENd6;
class ENdN;
class EKeyW;
class EKCount;
class EKSum;
class EKRepeat;
class EKMean;
class EKAcc;
class PredBranch;
class PredAnd;
class PredOr;
class PredXOr;
class PredEQ;
class PredNEQ;
class PredGT;
class PredLT;
class PredGTEq;
class PredLTEq;
class PredIsStr;
class PredInd;
class PredRange;
class PredRStep;
class ESeqFilt;
class ECall;
class SVarAs;
class SFDef;
class ListExp;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitCmd(Cmd *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitNumeral(Numeral *p) = 0;
  virtual void visitVal(Val *p) = 0;
  virtual void visitExpSeq(ExpSeq *p) = 0;
  virtual void visitExpD(ExpD *p) = 0;
  virtual void visitExpKW(ExpKW *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitExpCmd(ExpCmd *p) = 0;
  virtual void visitStmtCmd(StmtCmd *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitIntNum(IntNum *p) = 0;
  virtual void visitIntNegNum(IntNegNum *p) = 0;
  virtual void visitEVal(EVal *p) = 0;
  virtual void visitValNum(ValNum *p) = 0;
  virtual void visitValVar(ValVar *p) = 0;
  virtual void visitValStr(ValStr *p) = 0;
  virtual void visitESeq(ESeq *p) = 0;
  virtual void visitERange(ERange *p) = 0;
  virtual void visitERStep(ERStep *p) = 0;
  virtual void visitEVect(EVect *p) = 0;
  virtual void visitEDice(EDice *p) = 0;
  virtual void visitE1d6(E1d6 *p) = 0;
  virtual void visitE1dN(E1dN *p) = 0;
  virtual void visitENd6(ENd6 *p) = 0;
  virtual void visitENdN(ENdN *p) = 0;
  virtual void visitEKeyW(EKeyW *p) = 0;
  virtual void visitEKCount(EKCount *p) = 0;
  virtual void visitEKSum(EKSum *p) = 0;
  virtual void visitEKRepeat(EKRepeat *p) = 0;
  virtual void visitEKMean(EKMean *p) = 0;
  virtual void visitEKAcc(EKAcc *p) = 0;
  virtual void visitPredBranch(PredBranch *p) = 0;
  virtual void visitPredAnd(PredAnd *p) = 0;
  virtual void visitPredOr(PredOr *p) = 0;
  virtual void visitPredXOr(PredXOr *p) = 0;
  virtual void visitPredEQ(PredEQ *p) = 0;
  virtual void visitPredNEQ(PredNEQ *p) = 0;
  virtual void visitPredGT(PredGT *p) = 0;
  virtual void visitPredLT(PredLT *p) = 0;
  virtual void visitPredGTEq(PredGTEq *p) = 0;
  virtual void visitPredLTEq(PredLTEq *p) = 0;
  virtual void visitPredIsStr(PredIsStr *p) = 0;
  virtual void visitPredInd(PredInd *p) = 0;
  virtual void visitPredRange(PredRange *p) = 0;
  virtual void visitPredRStep(PredRStep *p) = 0;
  virtual void visitESeqFilt(ESeqFilt *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitSVarAs(SVarAs *p) = 0;
  virtual void visitSFDef(SFDef *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitVarIdent(VarIdent x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Cmd : public Visitable
{
public:
  virtual Cmd *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Numeral : public Visitable
{
public:
  virtual Numeral *clone() const = 0;

};

class Val : public Visitable
{
public:
  virtual Val *clone() const = 0;

};

class ExpSeq : public Visitable
{
public:
  virtual ExpSeq *clone() const = 0;

};

class ExpD : public Visitable
{
public:
  virtual ExpD *clone() const = 0;

};

class ExpKW : public Visitable
{
public:
  virtual ExpKW *clone() const = 0;

};

class Pred : public Visitable
{
public:
  virtual Pred *clone() const = 0;

};

class Stmt : public Visitable
{
public:
  virtual Stmt *clone() const = 0;

};



class ExpCmd : public Cmd
{
public:
  Exp *exp_;

  ExpCmd(const ExpCmd &);
  ExpCmd &operator=(const ExpCmd &);
  ExpCmd(Exp *p1);
  ~ExpCmd();
  virtual void accept(Visitor *v);
  virtual ExpCmd *clone() const;
  void swap(ExpCmd &);
};

class StmtCmd : public Cmd
{
public:
  Stmt *stmt_;

  StmtCmd(const StmtCmd &);
  StmtCmd &operator=(const StmtCmd &);
  StmtCmd(Stmt *p1);
  ~StmtCmd();
  virtual void accept(Visitor *v);
  virtual StmtCmd *clone() const;
  void swap(StmtCmd &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EVal : public Exp
{
public:
  Val *val_;

  EVal(const EVal &);
  EVal &operator=(const EVal &);
  EVal(Val *p1);
  ~EVal();
  virtual void accept(Visitor *v);
  virtual EVal *clone() const;
  void swap(EVal &);
};

class ESeq : public Exp
{
public:
  ExpSeq *expseq_;

  ESeq(const ESeq &);
  ESeq &operator=(const ESeq &);
  ESeq(ExpSeq *p1);
  ~ESeq();
  virtual void accept(Visitor *v);
  virtual ESeq *clone() const;
  void swap(ESeq &);
};

class EDice : public Exp
{
public:
  ExpD *expd_;

  EDice(const EDice &);
  EDice &operator=(const EDice &);
  EDice(ExpD *p1);
  ~EDice();
  virtual void accept(Visitor *v);
  virtual EDice *clone() const;
  void swap(EDice &);
};

class EKeyW : public Exp
{
public:
  ExpKW *expkw_;

  EKeyW(const EKeyW &);
  EKeyW &operator=(const EKeyW &);
  EKeyW(ExpKW *p1);
  ~EKeyW();
  virtual void accept(Visitor *v);
  virtual EKeyW *clone() const;
  void swap(EKeyW &);
};

class ESeqFilt : public Exp
{
public:
  Exp *exp_;
  Pred *pred_;

  ESeqFilt(const ESeqFilt &);
  ESeqFilt &operator=(const ESeqFilt &);
  ESeqFilt(Exp *p1, Pred *p2);
  ~ESeqFilt();
  virtual void accept(Visitor *v);
  virtual ESeqFilt *clone() const;
  void swap(ESeqFilt &);
};

class ECall : public Exp
{
public:
  VarIdent varident_;
  ListExp *listexp_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(VarIdent p1, ListExp *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual ECall *clone() const;
  void swap(ECall &);
};

class IntNum : public Numeral
{
public:
  Integer integer_;

  IntNum(const IntNum &);
  IntNum &operator=(const IntNum &);
  IntNum(Integer p1);
  ~IntNum();
  virtual void accept(Visitor *v);
  virtual IntNum *clone() const;
  void swap(IntNum &);
};

class IntNegNum : public Numeral
{
public:
  Integer integer_;

  IntNegNum(const IntNegNum &);
  IntNegNum &operator=(const IntNegNum &);
  IntNegNum(Integer p1);
  ~IntNegNum();
  virtual void accept(Visitor *v);
  virtual IntNegNum *clone() const;
  void swap(IntNegNum &);
};

class ValNum : public Val
{
public:
  Numeral *numeral_;

  ValNum(const ValNum &);
  ValNum &operator=(const ValNum &);
  ValNum(Numeral *p1);
  ~ValNum();
  virtual void accept(Visitor *v);
  virtual ValNum *clone() const;
  void swap(ValNum &);
};

class ValVar : public Val
{
public:
  VarIdent varident_;

  ValVar(const ValVar &);
  ValVar &operator=(const ValVar &);
  ValVar(VarIdent p1);
  ~ValVar();
  virtual void accept(Visitor *v);
  virtual ValVar *clone() const;
  void swap(ValVar &);
};

class ValStr : public Val
{
public:
  String string_;

  ValStr(const ValStr &);
  ValStr &operator=(const ValStr &);
  ValStr(String p1);
  ~ValStr();
  virtual void accept(Visitor *v);
  virtual ValStr *clone() const;
  void swap(ValStr &);
};

class ERange : public ExpSeq
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ERange(const ERange &);
  ERange &operator=(const ERange &);
  ERange(Exp *p1, Exp *p2);
  ~ERange();
  virtual void accept(Visitor *v);
  virtual ERange *clone() const;
  void swap(ERange &);
};

class ERStep : public ExpSeq
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  ERStep(const ERStep &);
  ERStep &operator=(const ERStep &);
  ERStep(Exp *p1, Exp *p2, Exp *p3);
  ~ERStep();
  virtual void accept(Visitor *v);
  virtual ERStep *clone() const;
  void swap(ERStep &);
};

class EVect : public ExpSeq
{
public:
  ListExp *listexp_;

  EVect(const EVect &);
  EVect &operator=(const EVect &);
  EVect(ListExp *p1);
  ~EVect();
  virtual void accept(Visitor *v);
  virtual EVect *clone() const;
  void swap(EVect &);
};

class E1d6 : public ExpD
{
public:

  E1d6(const E1d6 &);
  E1d6 &operator=(const E1d6 &);
  E1d6();
  ~E1d6();
  virtual void accept(Visitor *v);
  virtual E1d6 *clone() const;
  void swap(E1d6 &);
};

class E1dN : public ExpD
{
public:
  Exp *exp_;

  E1dN(const E1dN &);
  E1dN &operator=(const E1dN &);
  E1dN(Exp *p1);
  ~E1dN();
  virtual void accept(Visitor *v);
  virtual E1dN *clone() const;
  void swap(E1dN &);
};

class ENd6 : public ExpD
{
public:
  Exp *exp_;

  ENd6(const ENd6 &);
  ENd6 &operator=(const ENd6 &);
  ENd6(Exp *p1);
  ~ENd6();
  virtual void accept(Visitor *v);
  virtual ENd6 *clone() const;
  void swap(ENd6 &);
};

class ENdN : public ExpD
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENdN(const ENdN &);
  ENdN &operator=(const ENdN &);
  ENdN(Exp *p1, Exp *p2);
  ~ENdN();
  virtual void accept(Visitor *v);
  virtual ENdN *clone() const;
  void swap(ENdN &);
};

class EKCount : public ExpKW
{
public:
  Exp *exp_;

  EKCount(const EKCount &);
  EKCount &operator=(const EKCount &);
  EKCount(Exp *p1);
  ~EKCount();
  virtual void accept(Visitor *v);
  virtual EKCount *clone() const;
  void swap(EKCount &);
};

class EKSum : public ExpKW
{
public:
  Exp *exp_;

  EKSum(const EKSum &);
  EKSum &operator=(const EKSum &);
  EKSum(Exp *p1);
  ~EKSum();
  virtual void accept(Visitor *v);
  virtual EKSum *clone() const;
  void swap(EKSum &);
};

class EKRepeat : public ExpKW
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EKRepeat(const EKRepeat &);
  EKRepeat &operator=(const EKRepeat &);
  EKRepeat(Exp *p1, Exp *p2);
  ~EKRepeat();
  virtual void accept(Visitor *v);
  virtual EKRepeat *clone() const;
  void swap(EKRepeat &);
};

class EKMean : public ExpKW
{
public:
  Exp *exp_;

  EKMean(const EKMean &);
  EKMean &operator=(const EKMean &);
  EKMean(Exp *p1);
  ~EKMean();
  virtual void accept(Visitor *v);
  virtual EKMean *clone() const;
  void swap(EKMean &);
};

class EKAcc : public ExpKW
{
public:
  Exp *exp_;
  VarIdent varident_;

  EKAcc(const EKAcc &);
  EKAcc &operator=(const EKAcc &);
  EKAcc(Exp *p1, VarIdent p2);
  ~EKAcc();
  virtual void accept(Visitor *v);
  virtual EKAcc *clone() const;
  void swap(EKAcc &);
};

class PredBranch : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredBranch(const PredBranch &);
  PredBranch &operator=(const PredBranch &);
  PredBranch(Pred *p1, Pred *p2);
  ~PredBranch();
  virtual void accept(Visitor *v);
  virtual PredBranch *clone() const;
  void swap(PredBranch &);
};

class PredAnd : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredAnd(const PredAnd &);
  PredAnd &operator=(const PredAnd &);
  PredAnd(Pred *p1, Pred *p2);
  ~PredAnd();
  virtual void accept(Visitor *v);
  virtual PredAnd *clone() const;
  void swap(PredAnd &);
};

class PredOr : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredOr(const PredOr &);
  PredOr &operator=(const PredOr &);
  PredOr(Pred *p1, Pred *p2);
  ~PredOr();
  virtual void accept(Visitor *v);
  virtual PredOr *clone() const;
  void swap(PredOr &);
};

class PredXOr : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredXOr(const PredXOr &);
  PredXOr &operator=(const PredXOr &);
  PredXOr(Pred *p1, Pred *p2);
  ~PredXOr();
  virtual void accept(Visitor *v);
  virtual PredXOr *clone() const;
  void swap(PredXOr &);
};

class PredEQ : public Pred
{
public:
  Val *val_;

  PredEQ(const PredEQ &);
  PredEQ &operator=(const PredEQ &);
  PredEQ(Val *p1);
  ~PredEQ();
  virtual void accept(Visitor *v);
  virtual PredEQ *clone() const;
  void swap(PredEQ &);
};

class PredNEQ : public Pred
{
public:
  Val *val_;

  PredNEQ(const PredNEQ &);
  PredNEQ &operator=(const PredNEQ &);
  PredNEQ(Val *p1);
  ~PredNEQ();
  virtual void accept(Visitor *v);
  virtual PredNEQ *clone() const;
  void swap(PredNEQ &);
};

class PredGT : public Pred
{
public:
  Val *val_;

  PredGT(const PredGT &);
  PredGT &operator=(const PredGT &);
  PredGT(Val *p1);
  ~PredGT();
  virtual void accept(Visitor *v);
  virtual PredGT *clone() const;
  void swap(PredGT &);
};

class PredLT : public Pred
{
public:
  Val *val_;

  PredLT(const PredLT &);
  PredLT &operator=(const PredLT &);
  PredLT(Val *p1);
  ~PredLT();
  virtual void accept(Visitor *v);
  virtual PredLT *clone() const;
  void swap(PredLT &);
};

class PredGTEq : public Pred
{
public:
  Val *val_;

  PredGTEq(const PredGTEq &);
  PredGTEq &operator=(const PredGTEq &);
  PredGTEq(Val *p1);
  ~PredGTEq();
  virtual void accept(Visitor *v);
  virtual PredGTEq *clone() const;
  void swap(PredGTEq &);
};

class PredLTEq : public Pred
{
public:
  Val *val_;

  PredLTEq(const PredLTEq &);
  PredLTEq &operator=(const PredLTEq &);
  PredLTEq(Val *p1);
  ~PredLTEq();
  virtual void accept(Visitor *v);
  virtual PredLTEq *clone() const;
  void swap(PredLTEq &);
};

class PredIsStr : public Pred
{
public:
  Val *val_;

  PredIsStr(const PredIsStr &);
  PredIsStr &operator=(const PredIsStr &);
  PredIsStr(Val *p1);
  ~PredIsStr();
  virtual void accept(Visitor *v);
  virtual PredIsStr *clone() const;
  void swap(PredIsStr &);
};

class PredInd : public Pred
{
public:
  Val *val_;

  PredInd(const PredInd &);
  PredInd &operator=(const PredInd &);
  PredInd(Val *p1);
  ~PredInd();
  virtual void accept(Visitor *v);
  virtual PredInd *clone() const;
  void swap(PredInd &);
};

class PredRange : public Pred
{
public:
  Val *val_1;
  Val *val_2;

  PredRange(const PredRange &);
  PredRange &operator=(const PredRange &);
  PredRange(Val *p1, Val *p2);
  ~PredRange();
  virtual void accept(Visitor *v);
  virtual PredRange *clone() const;
  void swap(PredRange &);
};

class PredRStep : public Pred
{
public:
  Val *val_1;
  Val *val_2;
  Val *val_3;

  PredRStep(const PredRStep &);
  PredRStep &operator=(const PredRStep &);
  PredRStep(Val *p1, Val *p2, Val *p3);
  ~PredRStep();
  virtual void accept(Visitor *v);
  virtual PredRStep *clone() const;
  void swap(PredRStep &);
};

class SVarAs : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarAs(const SVarAs &);
  SVarAs &operator=(const SVarAs &);
  SVarAs(VarIdent p1, Exp *p2);
  ~SVarAs();
  virtual void accept(Visitor *v);
  virtual SVarAs *clone() const;
  void swap(SVarAs &);
};

class SFDef : public Stmt
{
public:
  VarIdent varident_;
  ListExp *listexp_;
  Exp *exp_;

  SFDef(const SFDef &);
  SFDef &operator=(const SFDef &);
  SFDef(VarIdent p1, ListExp *p2, Exp *p3);
  ~SFDef();
  virtual void accept(Visitor *v);
  virtual SFDef *clone() const;
  void swap(SFDef &);
};



class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};



#endif
