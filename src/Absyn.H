#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string VarIdent;


/********************   Forward Declarations    ********************/

class Cmd;
class Exp;
class Numeral;
class Val;
class Range;
class ExpD;
class ExpKW;
class Pred;
class Stmt;
class ExpCmd;
class StmtCmd;
class EAdd;
class ESub;
class EMul;
class EDiv;
class EPow;
class ENeg;
class NumInt;
class NumFloat;
class EVal;
class ValNum;
class ValVar;
class ValStr;
class EList;
class ERange;
class RSimple;
class RStep;
class RInf;
class RStepInf;
class EDice;
class E1d6;
class E1dN;
class ENd6;
class ENdN;
class EKeyW;
class EKWRepeat;
class EKWCount;
class EKWSum;
class EKWMean;
class EKWSqrt;
class EKWFloor;
class EKWCeil;
class EKWRound;
class EKWTrunc;
class EKWAcc;
class PredAnd;
class PredOr;
class PredXOr;
class PredEQ;
class PredGT;
class PredLT;
class PredGTEq;
class PredLTEq;
class PredNot;
class PredIsStr;
class PredIsInt;
class PredIsFloat;
class PredInd;
class ESeqFilt;
class ECall;
class SVarAs;
class SVarAdd;
class SVarSub;
class SVarMul;
class SVarDiv;
class SFunDef;
class ListExp;
class ListPred;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitCmd(Cmd *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitNumeral(Numeral *p) = 0;
  virtual void visitVal(Val *p) = 0;
  virtual void visitRange(Range *p) = 0;
  virtual void visitExpD(ExpD *p) = 0;
  virtual void visitExpKW(ExpKW *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitExpCmd(ExpCmd *p) = 0;
  virtual void visitStmtCmd(StmtCmd *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEPow(EPow *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitNumInt(NumInt *p) = 0;
  virtual void visitNumFloat(NumFloat *p) = 0;
  virtual void visitEVal(EVal *p) = 0;
  virtual void visitValNum(ValNum *p) = 0;
  virtual void visitValVar(ValVar *p) = 0;
  virtual void visitValStr(ValStr *p) = 0;
  virtual void visitEList(EList *p) = 0;
  virtual void visitERange(ERange *p) = 0;
  virtual void visitRSimple(RSimple *p) = 0;
  virtual void visitRStep(RStep *p) = 0;
  virtual void visitRInf(RInf *p) = 0;
  virtual void visitRStepInf(RStepInf *p) = 0;
  virtual void visitEDice(EDice *p) = 0;
  virtual void visitE1d6(E1d6 *p) = 0;
  virtual void visitE1dN(E1dN *p) = 0;
  virtual void visitENd6(ENd6 *p) = 0;
  virtual void visitENdN(ENdN *p) = 0;
  virtual void visitEKeyW(EKeyW *p) = 0;
  virtual void visitEKWRepeat(EKWRepeat *p) = 0;
  virtual void visitEKWCount(EKWCount *p) = 0;
  virtual void visitEKWSum(EKWSum *p) = 0;
  virtual void visitEKWMean(EKWMean *p) = 0;
  virtual void visitEKWSqrt(EKWSqrt *p) = 0;
  virtual void visitEKWFloor(EKWFloor *p) = 0;
  virtual void visitEKWCeil(EKWCeil *p) = 0;
  virtual void visitEKWRound(EKWRound *p) = 0;
  virtual void visitEKWTrunc(EKWTrunc *p) = 0;
  virtual void visitEKWAcc(EKWAcc *p) = 0;
  virtual void visitPredAnd(PredAnd *p) = 0;
  virtual void visitPredOr(PredOr *p) = 0;
  virtual void visitPredXOr(PredXOr *p) = 0;
  virtual void visitPredEQ(PredEQ *p) = 0;
  virtual void visitPredGT(PredGT *p) = 0;
  virtual void visitPredLT(PredLT *p) = 0;
  virtual void visitPredGTEq(PredGTEq *p) = 0;
  virtual void visitPredLTEq(PredLTEq *p) = 0;
  virtual void visitPredNot(PredNot *p) = 0;
  virtual void visitPredIsStr(PredIsStr *p) = 0;
  virtual void visitPredIsInt(PredIsInt *p) = 0;
  virtual void visitPredIsFloat(PredIsFloat *p) = 0;
  virtual void visitPredInd(PredInd *p) = 0;
  virtual void visitESeqFilt(ESeqFilt *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitSVarAs(SVarAs *p) = 0;
  virtual void visitSVarAdd(SVarAdd *p) = 0;
  virtual void visitSVarSub(SVarSub *p) = 0;
  virtual void visitSVarMul(SVarMul *p) = 0;
  virtual void visitSVarDiv(SVarDiv *p) = 0;
  virtual void visitSFunDef(SFunDef *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListPred(ListPred *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitVarIdent(VarIdent x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Cmd : public Visitable
{
public:
  virtual Cmd *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Numeral : public Visitable
{
public:
  virtual Numeral *clone() const = 0;

};

class Val : public Visitable
{
public:
  virtual Val *clone() const = 0;

};

class Range : public Visitable
{
public:
  virtual Range *clone() const = 0;

};

class ExpD : public Visitable
{
public:
  virtual ExpD *clone() const = 0;

};

class ExpKW : public Visitable
{
public:
  virtual ExpKW *clone() const = 0;

};

class Pred : public Visitable
{
public:
  virtual Pred *clone() const = 0;

};

class Stmt : public Visitable
{
public:
  virtual Stmt *clone() const = 0;

};



class ExpCmd : public Cmd
{
public:
  Exp *exp_;

  ExpCmd(const ExpCmd &);
  ExpCmd &operator=(const ExpCmd &);
  ExpCmd(Exp *p1);
  ~ExpCmd();
  virtual void accept(Visitor *v);
  virtual ExpCmd *clone() const;
  void swap(ExpCmd &);
};

class StmtCmd : public Cmd
{
public:
  Stmt *stmt_;

  StmtCmd(const StmtCmd &);
  StmtCmd &operator=(const StmtCmd &);
  StmtCmd(Stmt *p1);
  ~StmtCmd();
  virtual void accept(Visitor *v);
  virtual StmtCmd *clone() const;
  void swap(StmtCmd &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EPow : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EPow(const EPow &);
  EPow &operator=(const EPow &);
  EPow(Exp *p1, Exp *p2);
  ~EPow();
  virtual void accept(Visitor *v);
  virtual EPow *clone() const;
  void swap(EPow &);
};

class ENeg : public Exp
{
public:
  Exp *exp_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Exp *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual ENeg *clone() const;
  void swap(ENeg &);
};

class EVal : public Exp
{
public:
  Val *val_;

  EVal(const EVal &);
  EVal &operator=(const EVal &);
  EVal(Val *p1);
  ~EVal();
  virtual void accept(Visitor *v);
  virtual EVal *clone() const;
  void swap(EVal &);
};

class EList : public Exp
{
public:
  ListExp *listexp_;

  EList(const EList &);
  EList &operator=(const EList &);
  EList(ListExp *p1);
  ~EList();
  virtual void accept(Visitor *v);
  virtual EList *clone() const;
  void swap(EList &);
};

class ERange : public Exp
{
public:
  Range *range_;

  ERange(const ERange &);
  ERange &operator=(const ERange &);
  ERange(Range *p1);
  ~ERange();
  virtual void accept(Visitor *v);
  virtual ERange *clone() const;
  void swap(ERange &);
};

class EDice : public Exp
{
public:
  ExpD *expd_;

  EDice(const EDice &);
  EDice &operator=(const EDice &);
  EDice(ExpD *p1);
  ~EDice();
  virtual void accept(Visitor *v);
  virtual EDice *clone() const;
  void swap(EDice &);
};

class EKeyW : public Exp
{
public:
  ExpKW *expkw_;

  EKeyW(const EKeyW &);
  EKeyW &operator=(const EKeyW &);
  EKeyW(ExpKW *p1);
  ~EKeyW();
  virtual void accept(Visitor *v);
  virtual EKeyW *clone() const;
  void swap(EKeyW &);
};

class ESeqFilt : public Exp
{
public:
  Exp *exp_;
  ListPred *listpred_;

  ESeqFilt(const ESeqFilt &);
  ESeqFilt &operator=(const ESeqFilt &);
  ESeqFilt(Exp *p1, ListPred *p2);
  ~ESeqFilt();
  virtual void accept(Visitor *v);
  virtual ESeqFilt *clone() const;
  void swap(ESeqFilt &);
};

class ECall : public Exp
{
public:
  VarIdent varident_;
  ListExp *listexp_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(VarIdent p1, ListExp *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual ECall *clone() const;
  void swap(ECall &);
};

class NumInt : public Numeral
{
public:
  Integer integer_;

  NumInt(const NumInt &);
  NumInt &operator=(const NumInt &);
  NumInt(Integer p1);
  ~NumInt();
  virtual void accept(Visitor *v);
  virtual NumInt *clone() const;
  void swap(NumInt &);
};

class NumFloat : public Numeral
{
public:
  Double double_;

  NumFloat(const NumFloat &);
  NumFloat &operator=(const NumFloat &);
  NumFloat(Double p1);
  ~NumFloat();
  virtual void accept(Visitor *v);
  virtual NumFloat *clone() const;
  void swap(NumFloat &);
};

class ValNum : public Val
{
public:
  Numeral *numeral_;

  ValNum(const ValNum &);
  ValNum &operator=(const ValNum &);
  ValNum(Numeral *p1);
  ~ValNum();
  virtual void accept(Visitor *v);
  virtual ValNum *clone() const;
  void swap(ValNum &);
};

class ValVar : public Val
{
public:
  VarIdent varident_;

  ValVar(const ValVar &);
  ValVar &operator=(const ValVar &);
  ValVar(VarIdent p1);
  ~ValVar();
  virtual void accept(Visitor *v);
  virtual ValVar *clone() const;
  void swap(ValVar &);
};

class ValStr : public Val
{
public:
  String string_;

  ValStr(const ValStr &);
  ValStr &operator=(const ValStr &);
  ValStr(String p1);
  ~ValStr();
  virtual void accept(Visitor *v);
  virtual ValStr *clone() const;
  void swap(ValStr &);
};

class RSimple : public Range
{
public:
  Exp *exp_1;
  Exp *exp_2;

  RSimple(const RSimple &);
  RSimple &operator=(const RSimple &);
  RSimple(Exp *p1, Exp *p2);
  ~RSimple();
  virtual void accept(Visitor *v);
  virtual RSimple *clone() const;
  void swap(RSimple &);
};

class RStep : public Range
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  RStep(const RStep &);
  RStep &operator=(const RStep &);
  RStep(Exp *p1, Exp *p2, Exp *p3);
  ~RStep();
  virtual void accept(Visitor *v);
  virtual RStep *clone() const;
  void swap(RStep &);
};

class RInf : public Range
{
public:
  Exp *exp_;

  RInf(const RInf &);
  RInf &operator=(const RInf &);
  RInf(Exp *p1);
  ~RInf();
  virtual void accept(Visitor *v);
  virtual RInf *clone() const;
  void swap(RInf &);
};

class RStepInf : public Range
{
public:
  Exp *exp_1;
  Exp *exp_2;

  RStepInf(const RStepInf &);
  RStepInf &operator=(const RStepInf &);
  RStepInf(Exp *p1, Exp *p2);
  ~RStepInf();
  virtual void accept(Visitor *v);
  virtual RStepInf *clone() const;
  void swap(RStepInf &);
};

class E1d6 : public ExpD
{
public:

  E1d6(const E1d6 &);
  E1d6 &operator=(const E1d6 &);
  E1d6();
  ~E1d6();
  virtual void accept(Visitor *v);
  virtual E1d6 *clone() const;
  void swap(E1d6 &);
};

class E1dN : public ExpD
{
public:
  Exp *exp_;

  E1dN(const E1dN &);
  E1dN &operator=(const E1dN &);
  E1dN(Exp *p1);
  ~E1dN();
  virtual void accept(Visitor *v);
  virtual E1dN *clone() const;
  void swap(E1dN &);
};

class ENd6 : public ExpD
{
public:
  Exp *exp_;

  ENd6(const ENd6 &);
  ENd6 &operator=(const ENd6 &);
  ENd6(Exp *p1);
  ~ENd6();
  virtual void accept(Visitor *v);
  virtual ENd6 *clone() const;
  void swap(ENd6 &);
};

class ENdN : public ExpD
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENdN(const ENdN &);
  ENdN &operator=(const ENdN &);
  ENdN(Exp *p1, Exp *p2);
  ~ENdN();
  virtual void accept(Visitor *v);
  virtual ENdN *clone() const;
  void swap(ENdN &);
};

class EKWRepeat : public ExpKW
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EKWRepeat(const EKWRepeat &);
  EKWRepeat &operator=(const EKWRepeat &);
  EKWRepeat(Exp *p1, Exp *p2);
  ~EKWRepeat();
  virtual void accept(Visitor *v);
  virtual EKWRepeat *clone() const;
  void swap(EKWRepeat &);
};

class EKWCount : public ExpKW
{
public:
  Exp *exp_;

  EKWCount(const EKWCount &);
  EKWCount &operator=(const EKWCount &);
  EKWCount(Exp *p1);
  ~EKWCount();
  virtual void accept(Visitor *v);
  virtual EKWCount *clone() const;
  void swap(EKWCount &);
};

class EKWSum : public ExpKW
{
public:
  Exp *exp_;

  EKWSum(const EKWSum &);
  EKWSum &operator=(const EKWSum &);
  EKWSum(Exp *p1);
  ~EKWSum();
  virtual void accept(Visitor *v);
  virtual EKWSum *clone() const;
  void swap(EKWSum &);
};

class EKWMean : public ExpKW
{
public:
  Exp *exp_;

  EKWMean(const EKWMean &);
  EKWMean &operator=(const EKWMean &);
  EKWMean(Exp *p1);
  ~EKWMean();
  virtual void accept(Visitor *v);
  virtual EKWMean *clone() const;
  void swap(EKWMean &);
};

class EKWSqrt : public ExpKW
{
public:
  Exp *exp_;

  EKWSqrt(const EKWSqrt &);
  EKWSqrt &operator=(const EKWSqrt &);
  EKWSqrt(Exp *p1);
  ~EKWSqrt();
  virtual void accept(Visitor *v);
  virtual EKWSqrt *clone() const;
  void swap(EKWSqrt &);
};

class EKWFloor : public ExpKW
{
public:
  Exp *exp_;

  EKWFloor(const EKWFloor &);
  EKWFloor &operator=(const EKWFloor &);
  EKWFloor(Exp *p1);
  ~EKWFloor();
  virtual void accept(Visitor *v);
  virtual EKWFloor *clone() const;
  void swap(EKWFloor &);
};

class EKWCeil : public ExpKW
{
public:
  Exp *exp_;

  EKWCeil(const EKWCeil &);
  EKWCeil &operator=(const EKWCeil &);
  EKWCeil(Exp *p1);
  ~EKWCeil();
  virtual void accept(Visitor *v);
  virtual EKWCeil *clone() const;
  void swap(EKWCeil &);
};

class EKWRound : public ExpKW
{
public:
  Exp *exp_;

  EKWRound(const EKWRound &);
  EKWRound &operator=(const EKWRound &);
  EKWRound(Exp *p1);
  ~EKWRound();
  virtual void accept(Visitor *v);
  virtual EKWRound *clone() const;
  void swap(EKWRound &);
};

class EKWTrunc : public ExpKW
{
public:
  Exp *exp_;

  EKWTrunc(const EKWTrunc &);
  EKWTrunc &operator=(const EKWTrunc &);
  EKWTrunc(Exp *p1);
  ~EKWTrunc();
  virtual void accept(Visitor *v);
  virtual EKWTrunc *clone() const;
  void swap(EKWTrunc &);
};

class EKWAcc : public ExpKW
{
public:
  Exp *exp_;
  VarIdent varident_;

  EKWAcc(const EKWAcc &);
  EKWAcc &operator=(const EKWAcc &);
  EKWAcc(Exp *p1, VarIdent p2);
  ~EKWAcc();
  virtual void accept(Visitor *v);
  virtual EKWAcc *clone() const;
  void swap(EKWAcc &);
};

class PredAnd : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredAnd(const PredAnd &);
  PredAnd &operator=(const PredAnd &);
  PredAnd(Pred *p1, Pred *p2);
  ~PredAnd();
  virtual void accept(Visitor *v);
  virtual PredAnd *clone() const;
  void swap(PredAnd &);
};

class PredOr : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredOr(const PredOr &);
  PredOr &operator=(const PredOr &);
  PredOr(Pred *p1, Pred *p2);
  ~PredOr();
  virtual void accept(Visitor *v);
  virtual PredOr *clone() const;
  void swap(PredOr &);
};

class PredXOr : public Pred
{
public:
  Pred *pred_1;
  Pred *pred_2;

  PredXOr(const PredXOr &);
  PredXOr &operator=(const PredXOr &);
  PredXOr(Pred *p1, Pred *p2);
  ~PredXOr();
  virtual void accept(Visitor *v);
  virtual PredXOr *clone() const;
  void swap(PredXOr &);
};

class PredEQ : public Pred
{
public:
  Val *val_;

  PredEQ(const PredEQ &);
  PredEQ &operator=(const PredEQ &);
  PredEQ(Val *p1);
  ~PredEQ();
  virtual void accept(Visitor *v);
  virtual PredEQ *clone() const;
  void swap(PredEQ &);
};

class PredGT : public Pred
{
public:
  Val *val_;

  PredGT(const PredGT &);
  PredGT &operator=(const PredGT &);
  PredGT(Val *p1);
  ~PredGT();
  virtual void accept(Visitor *v);
  virtual PredGT *clone() const;
  void swap(PredGT &);
};

class PredLT : public Pred
{
public:
  Val *val_;

  PredLT(const PredLT &);
  PredLT &operator=(const PredLT &);
  PredLT(Val *p1);
  ~PredLT();
  virtual void accept(Visitor *v);
  virtual PredLT *clone() const;
  void swap(PredLT &);
};

class PredGTEq : public Pred
{
public:
  Val *val_;

  PredGTEq(const PredGTEq &);
  PredGTEq &operator=(const PredGTEq &);
  PredGTEq(Val *p1);
  ~PredGTEq();
  virtual void accept(Visitor *v);
  virtual PredGTEq *clone() const;
  void swap(PredGTEq &);
};

class PredLTEq : public Pred
{
public:
  Val *val_;

  PredLTEq(const PredLTEq &);
  PredLTEq &operator=(const PredLTEq &);
  PredLTEq(Val *p1);
  ~PredLTEq();
  virtual void accept(Visitor *v);
  virtual PredLTEq *clone() const;
  void swap(PredLTEq &);
};

class PredNot : public Pred
{
public:
  Pred *pred_;

  PredNot(const PredNot &);
  PredNot &operator=(const PredNot &);
  PredNot(Pred *p1);
  ~PredNot();
  virtual void accept(Visitor *v);
  virtual PredNot *clone() const;
  void swap(PredNot &);
};

class PredIsStr : public Pred
{
public:

  PredIsStr(const PredIsStr &);
  PredIsStr &operator=(const PredIsStr &);
  PredIsStr();
  ~PredIsStr();
  virtual void accept(Visitor *v);
  virtual PredIsStr *clone() const;
  void swap(PredIsStr &);
};

class PredIsInt : public Pred
{
public:

  PredIsInt(const PredIsInt &);
  PredIsInt &operator=(const PredIsInt &);
  PredIsInt();
  ~PredIsInt();
  virtual void accept(Visitor *v);
  virtual PredIsInt *clone() const;
  void swap(PredIsInt &);
};

class PredIsFloat : public Pred
{
public:

  PredIsFloat(const PredIsFloat &);
  PredIsFloat &operator=(const PredIsFloat &);
  PredIsFloat();
  ~PredIsFloat();
  virtual void accept(Visitor *v);
  virtual PredIsFloat *clone() const;
  void swap(PredIsFloat &);
};

class PredInd : public Pred
{
public:
  Exp *exp_;

  PredInd(const PredInd &);
  PredInd &operator=(const PredInd &);
  PredInd(Exp *p1);
  ~PredInd();
  virtual void accept(Visitor *v);
  virtual PredInd *clone() const;
  void swap(PredInd &);
};

class SVarAs : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarAs(const SVarAs &);
  SVarAs &operator=(const SVarAs &);
  SVarAs(VarIdent p1, Exp *p2);
  ~SVarAs();
  virtual void accept(Visitor *v);
  virtual SVarAs *clone() const;
  void swap(SVarAs &);
};

class SVarAdd : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarAdd(const SVarAdd &);
  SVarAdd &operator=(const SVarAdd &);
  SVarAdd(VarIdent p1, Exp *p2);
  ~SVarAdd();
  virtual void accept(Visitor *v);
  virtual SVarAdd *clone() const;
  void swap(SVarAdd &);
};

class SVarSub : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarSub(const SVarSub &);
  SVarSub &operator=(const SVarSub &);
  SVarSub(VarIdent p1, Exp *p2);
  ~SVarSub();
  virtual void accept(Visitor *v);
  virtual SVarSub *clone() const;
  void swap(SVarSub &);
};

class SVarMul : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarMul(const SVarMul &);
  SVarMul &operator=(const SVarMul &);
  SVarMul(VarIdent p1, Exp *p2);
  ~SVarMul();
  virtual void accept(Visitor *v);
  virtual SVarMul *clone() const;
  void swap(SVarMul &);
};

class SVarDiv : public Stmt
{
public:
  VarIdent varident_;
  Exp *exp_;

  SVarDiv(const SVarDiv &);
  SVarDiv &operator=(const SVarDiv &);
  SVarDiv(VarIdent p1, Exp *p2);
  ~SVarDiv();
  virtual void accept(Visitor *v);
  virtual SVarDiv *clone() const;
  void swap(SVarDiv &);
};

class SFunDef : public Stmt
{
public:
  VarIdent varident_;
  ListExp *listexp_;
  Exp *exp_;

  SFunDef(const SFunDef &);
  SFunDef &operator=(const SFunDef &);
  SFunDef(VarIdent p1, ListExp *p2, Exp *p3);
  ~SFunDef();
  virtual void accept(Visitor *v);
  virtual SFunDef *clone() const;
  void swap(SFunDef &);
};



class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListPred : public Visitable, public std::vector<Pred*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPred *clone() const;
};



#endif
