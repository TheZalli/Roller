//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   ExpCmd    ********************/
ExpCmd::ExpCmd(Exp *p1)
{
  exp_ = p1;

}

ExpCmd::ExpCmd(const ExpCmd & other)
{
  exp_ = other.exp_->clone();

}

ExpCmd &ExpCmd::operator=(const ExpCmd & other)
{
  ExpCmd tmp(other);
  swap(tmp);
  return *this;
}

void ExpCmd::swap(ExpCmd & other)
{
  std::swap(exp_, other.exp_);

}

ExpCmd::~ExpCmd()
{
  delete(exp_);

}

void ExpCmd::accept(Visitor *v)
{
  v->visitExpCmd(this);
}

ExpCmd *ExpCmd::clone() const
{
  return new ExpCmd(*this);
}



/********************   StmtCmd    ********************/
StmtCmd::StmtCmd(Stmt *p1)
{
  stmt_ = p1;

}

StmtCmd::StmtCmd(const StmtCmd & other)
{
  stmt_ = other.stmt_->clone();

}

StmtCmd &StmtCmd::operator=(const StmtCmd & other)
{
  StmtCmd tmp(other);
  swap(tmp);
  return *this;
}

void StmtCmd::swap(StmtCmd & other)
{
  std::swap(stmt_, other.stmt_);

}

StmtCmd::~StmtCmd()
{
  delete(stmt_);

}

void StmtCmd::accept(Visitor *v)
{
  v->visitStmtCmd(this);
}

StmtCmd *StmtCmd::clone() const
{
  return new StmtCmd(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPow    ********************/
EPow::EPow(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPow::EPow(const EPow & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPow &EPow::operator=(const EPow & other)
{
  EPow tmp(other);
  swap(tmp);
  return *this;
}

void EPow::swap(EPow & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPow::~EPow()
{
  delete(exp_1);
  delete(exp_2);

}

void EPow::accept(Visitor *v)
{
  v->visitEPow(this);
}

EPow *EPow::clone() const
{
  return new EPow(*this);
}



/********************   ENeg    ********************/
ENeg::ENeg(Exp *p1)
{
  exp_ = p1;

}

ENeg::ENeg(const ENeg & other)
{
  exp_ = other.exp_->clone();

}

ENeg &ENeg::operator=(const ENeg & other)
{
  ENeg tmp(other);
  swap(tmp);
  return *this;
}

void ENeg::swap(ENeg & other)
{
  std::swap(exp_, other.exp_);

}

ENeg::~ENeg()
{
  delete(exp_);

}

void ENeg::accept(Visitor *v)
{
  v->visitENeg(this);
}

ENeg *ENeg::clone() const
{
  return new ENeg(*this);
}



/********************   EVal    ********************/
EVal::EVal(Val *p1)
{
  val_ = p1;

}

EVal::EVal(const EVal & other)
{
  val_ = other.val_->clone();

}

EVal &EVal::operator=(const EVal & other)
{
  EVal tmp(other);
  swap(tmp);
  return *this;
}

void EVal::swap(EVal & other)
{
  std::swap(val_, other.val_);

}

EVal::~EVal()
{
  delete(val_);

}

void EVal::accept(Visitor *v)
{
  v->visitEVal(this);
}

EVal *EVal::clone() const
{
  return new EVal(*this);
}



/********************   EList    ********************/
EList::EList(ListExp *p1)
{
  listexp_ = p1;

}

EList::EList(const EList & other)
{
  listexp_ = other.listexp_->clone();

}

EList &EList::operator=(const EList & other)
{
  EList tmp(other);
  swap(tmp);
  return *this;
}

void EList::swap(EList & other)
{
  std::swap(listexp_, other.listexp_);

}

EList::~EList()
{
  delete(listexp_);

}

void EList::accept(Visitor *v)
{
  v->visitEList(this);
}

EList *EList::clone() const
{
  return new EList(*this);
}



/********************   ERange    ********************/
ERange::ERange(Range *p1)
{
  range_ = p1;

}

ERange::ERange(const ERange & other)
{
  range_ = other.range_->clone();

}

ERange &ERange::operator=(const ERange & other)
{
  ERange tmp(other);
  swap(tmp);
  return *this;
}

void ERange::swap(ERange & other)
{
  std::swap(range_, other.range_);

}

ERange::~ERange()
{
  delete(range_);

}

void ERange::accept(Visitor *v)
{
  v->visitERange(this);
}

ERange *ERange::clone() const
{
  return new ERange(*this);
}



/********************   EDice    ********************/
EDice::EDice(ExpD *p1)
{
  expd_ = p1;

}

EDice::EDice(const EDice & other)
{
  expd_ = other.expd_->clone();

}

EDice &EDice::operator=(const EDice & other)
{
  EDice tmp(other);
  swap(tmp);
  return *this;
}

void EDice::swap(EDice & other)
{
  std::swap(expd_, other.expd_);

}

EDice::~EDice()
{
  delete(expd_);

}

void EDice::accept(Visitor *v)
{
  v->visitEDice(this);
}

EDice *EDice::clone() const
{
  return new EDice(*this);
}



/********************   EKeyW    ********************/
EKeyW::EKeyW(ExpKW *p1)
{
  expkw_ = p1;

}

EKeyW::EKeyW(const EKeyW & other)
{
  expkw_ = other.expkw_->clone();

}

EKeyW &EKeyW::operator=(const EKeyW & other)
{
  EKeyW tmp(other);
  swap(tmp);
  return *this;
}

void EKeyW::swap(EKeyW & other)
{
  std::swap(expkw_, other.expkw_);

}

EKeyW::~EKeyW()
{
  delete(expkw_);

}

void EKeyW::accept(Visitor *v)
{
  v->visitEKeyW(this);
}

EKeyW *EKeyW::clone() const
{
  return new EKeyW(*this);
}



/********************   ESeqFilt    ********************/
ESeqFilt::ESeqFilt(Exp *p1, ListPred *p2)
{
  exp_ = p1;
  listpred_ = p2;

}

ESeqFilt::ESeqFilt(const ESeqFilt & other)
{
  exp_ = other.exp_->clone();
  listpred_ = other.listpred_->clone();

}

ESeqFilt &ESeqFilt::operator=(const ESeqFilt & other)
{
  ESeqFilt tmp(other);
  swap(tmp);
  return *this;
}

void ESeqFilt::swap(ESeqFilt & other)
{
  std::swap(exp_, other.exp_);
  std::swap(listpred_, other.listpred_);

}

ESeqFilt::~ESeqFilt()
{
  delete(exp_);
  delete(listpred_);

}

void ESeqFilt::accept(Visitor *v)
{
  v->visitESeqFilt(this);
}

ESeqFilt *ESeqFilt::clone() const
{
  return new ESeqFilt(*this);
}



/********************   ECall    ********************/
ECall::ECall(VarIdent p1, ListExp *p2)
{
  varident_ = p1;
  listexp_ = p2;

}

ECall::ECall(const ECall & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();

}

ECall &ECall::operator=(const ECall & other)
{
  ECall tmp(other);
  swap(tmp);
  return *this;
}

void ECall::swap(ECall & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);

}

ECall::~ECall()
{
  delete(listexp_);

}

void ECall::accept(Visitor *v)
{
  v->visitECall(this);
}

ECall *ECall::clone() const
{
  return new ECall(*this);
}



/********************   NumInt    ********************/
NumInt::NumInt(Integer p1)
{
  integer_ = p1;

}

NumInt::NumInt(const NumInt & other)
{
  integer_ = other.integer_;

}

NumInt &NumInt::operator=(const NumInt & other)
{
  NumInt tmp(other);
  swap(tmp);
  return *this;
}

void NumInt::swap(NumInt & other)
{
  std::swap(integer_, other.integer_);

}

NumInt::~NumInt()
{

}

void NumInt::accept(Visitor *v)
{
  v->visitNumInt(this);
}

NumInt *NumInt::clone() const
{
  return new NumInt(*this);
}



/********************   NumFloat    ********************/
NumFloat::NumFloat(Double p1)
{
  double_ = p1;

}

NumFloat::NumFloat(const NumFloat & other)
{
  double_ = other.double_;

}

NumFloat &NumFloat::operator=(const NumFloat & other)
{
  NumFloat tmp(other);
  swap(tmp);
  return *this;
}

void NumFloat::swap(NumFloat & other)
{
  std::swap(double_, other.double_);

}

NumFloat::~NumFloat()
{

}

void NumFloat::accept(Visitor *v)
{
  v->visitNumFloat(this);
}

NumFloat *NumFloat::clone() const
{
  return new NumFloat(*this);
}



/********************   ValNum    ********************/
ValNum::ValNum(Numeral *p1)
{
  numeral_ = p1;

}

ValNum::ValNum(const ValNum & other)
{
  numeral_ = other.numeral_->clone();

}

ValNum &ValNum::operator=(const ValNum & other)
{
  ValNum tmp(other);
  swap(tmp);
  return *this;
}

void ValNum::swap(ValNum & other)
{
  std::swap(numeral_, other.numeral_);

}

ValNum::~ValNum()
{
  delete(numeral_);

}

void ValNum::accept(Visitor *v)
{
  v->visitValNum(this);
}

ValNum *ValNum::clone() const
{
  return new ValNum(*this);
}



/********************   ValVar    ********************/
ValVar::ValVar(VarIdent p1)
{
  varident_ = p1;

}

ValVar::ValVar(const ValVar & other)
{
  varident_ = other.varident_;

}

ValVar &ValVar::operator=(const ValVar & other)
{
  ValVar tmp(other);
  swap(tmp);
  return *this;
}

void ValVar::swap(ValVar & other)
{
  std::swap(varident_, other.varident_);

}

ValVar::~ValVar()
{

}

void ValVar::accept(Visitor *v)
{
  v->visitValVar(this);
}

ValVar *ValVar::clone() const
{
  return new ValVar(*this);
}



/********************   ValStr    ********************/
ValStr::ValStr(String p1)
{
  string_ = p1;

}

ValStr::ValStr(const ValStr & other)
{
  string_ = other.string_;

}

ValStr &ValStr::operator=(const ValStr & other)
{
  ValStr tmp(other);
  swap(tmp);
  return *this;
}

void ValStr::swap(ValStr & other)
{
  std::swap(string_, other.string_);

}

ValStr::~ValStr()
{

}

void ValStr::accept(Visitor *v)
{
  v->visitValStr(this);
}

ValStr *ValStr::clone() const
{
  return new ValStr(*this);
}



/********************   RSimple    ********************/
RSimple::RSimple(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

RSimple::RSimple(const RSimple & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

RSimple &RSimple::operator=(const RSimple & other)
{
  RSimple tmp(other);
  swap(tmp);
  return *this;
}

void RSimple::swap(RSimple & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

RSimple::~RSimple()
{
  delete(exp_1);
  delete(exp_2);

}

void RSimple::accept(Visitor *v)
{
  v->visitRSimple(this);
}

RSimple *RSimple::clone() const
{
  return new RSimple(*this);
}



/********************   RStep    ********************/
RStep::RStep(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

RStep::RStep(const RStep & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

RStep &RStep::operator=(const RStep & other)
{
  RStep tmp(other);
  swap(tmp);
  return *this;
}

void RStep::swap(RStep & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

RStep::~RStep()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void RStep::accept(Visitor *v)
{
  v->visitRStep(this);
}

RStep *RStep::clone() const
{
  return new RStep(*this);
}



/********************   RInf    ********************/
RInf::RInf(Exp *p1)
{
  exp_ = p1;

}

RInf::RInf(const RInf & other)
{
  exp_ = other.exp_->clone();

}

RInf &RInf::operator=(const RInf & other)
{
  RInf tmp(other);
  swap(tmp);
  return *this;
}

void RInf::swap(RInf & other)
{
  std::swap(exp_, other.exp_);

}

RInf::~RInf()
{
  delete(exp_);

}

void RInf::accept(Visitor *v)
{
  v->visitRInf(this);
}

RInf *RInf::clone() const
{
  return new RInf(*this);
}



/********************   RStepInf    ********************/
RStepInf::RStepInf(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

RStepInf::RStepInf(const RStepInf & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

RStepInf &RStepInf::operator=(const RStepInf & other)
{
  RStepInf tmp(other);
  swap(tmp);
  return *this;
}

void RStepInf::swap(RStepInf & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

RStepInf::~RStepInf()
{
  delete(exp_1);
  delete(exp_2);

}

void RStepInf::accept(Visitor *v)
{
  v->visitRStepInf(this);
}

RStepInf *RStepInf::clone() const
{
  return new RStepInf(*this);
}



/********************   E1d6    ********************/
E1d6::E1d6()
{

}

E1d6::E1d6(const E1d6 & other)
{

}

E1d6 &E1d6::operator=(const E1d6 & other)
{
  E1d6 tmp(other);
  swap(tmp);
  return *this;
}

void E1d6::swap(E1d6 & other)
{

}

E1d6::~E1d6()
{

}

void E1d6::accept(Visitor *v)
{
  v->visitE1d6(this);
}

E1d6 *E1d6::clone() const
{
  return new E1d6(*this);
}



/********************   E1dN    ********************/
E1dN::E1dN(Exp *p1)
{
  exp_ = p1;

}

E1dN::E1dN(const E1dN & other)
{
  exp_ = other.exp_->clone();

}

E1dN &E1dN::operator=(const E1dN & other)
{
  E1dN tmp(other);
  swap(tmp);
  return *this;
}

void E1dN::swap(E1dN & other)
{
  std::swap(exp_, other.exp_);

}

E1dN::~E1dN()
{
  delete(exp_);

}

void E1dN::accept(Visitor *v)
{
  v->visitE1dN(this);
}

E1dN *E1dN::clone() const
{
  return new E1dN(*this);
}



/********************   ENd6    ********************/
ENd6::ENd6(Exp *p1)
{
  exp_ = p1;

}

ENd6::ENd6(const ENd6 & other)
{
  exp_ = other.exp_->clone();

}

ENd6 &ENd6::operator=(const ENd6 & other)
{
  ENd6 tmp(other);
  swap(tmp);
  return *this;
}

void ENd6::swap(ENd6 & other)
{
  std::swap(exp_, other.exp_);

}

ENd6::~ENd6()
{
  delete(exp_);

}

void ENd6::accept(Visitor *v)
{
  v->visitENd6(this);
}

ENd6 *ENd6::clone() const
{
  return new ENd6(*this);
}



/********************   ENdN    ********************/
ENdN::ENdN(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENdN::ENdN(const ENdN & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENdN &ENdN::operator=(const ENdN & other)
{
  ENdN tmp(other);
  swap(tmp);
  return *this;
}

void ENdN::swap(ENdN & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENdN::~ENdN()
{
  delete(exp_1);
  delete(exp_2);

}

void ENdN::accept(Visitor *v)
{
  v->visitENdN(this);
}

ENdN *ENdN::clone() const
{
  return new ENdN(*this);
}



/********************   EKWRepeat    ********************/
EKWRepeat::EKWRepeat(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EKWRepeat::EKWRepeat(const EKWRepeat & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EKWRepeat &EKWRepeat::operator=(const EKWRepeat & other)
{
  EKWRepeat tmp(other);
  swap(tmp);
  return *this;
}

void EKWRepeat::swap(EKWRepeat & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EKWRepeat::~EKWRepeat()
{
  delete(exp_1);
  delete(exp_2);

}

void EKWRepeat::accept(Visitor *v)
{
  v->visitEKWRepeat(this);
}

EKWRepeat *EKWRepeat::clone() const
{
  return new EKWRepeat(*this);
}



/********************   EKWCount    ********************/
EKWCount::EKWCount(Exp *p1)
{
  exp_ = p1;

}

EKWCount::EKWCount(const EKWCount & other)
{
  exp_ = other.exp_->clone();

}

EKWCount &EKWCount::operator=(const EKWCount & other)
{
  EKWCount tmp(other);
  swap(tmp);
  return *this;
}

void EKWCount::swap(EKWCount & other)
{
  std::swap(exp_, other.exp_);

}

EKWCount::~EKWCount()
{
  delete(exp_);

}

void EKWCount::accept(Visitor *v)
{
  v->visitEKWCount(this);
}

EKWCount *EKWCount::clone() const
{
  return new EKWCount(*this);
}



/********************   EKWSum    ********************/
EKWSum::EKWSum(Exp *p1)
{
  exp_ = p1;

}

EKWSum::EKWSum(const EKWSum & other)
{
  exp_ = other.exp_->clone();

}

EKWSum &EKWSum::operator=(const EKWSum & other)
{
  EKWSum tmp(other);
  swap(tmp);
  return *this;
}

void EKWSum::swap(EKWSum & other)
{
  std::swap(exp_, other.exp_);

}

EKWSum::~EKWSum()
{
  delete(exp_);

}

void EKWSum::accept(Visitor *v)
{
  v->visitEKWSum(this);
}

EKWSum *EKWSum::clone() const
{
  return new EKWSum(*this);
}



/********************   EKWMean    ********************/
EKWMean::EKWMean(Exp *p1)
{
  exp_ = p1;

}

EKWMean::EKWMean(const EKWMean & other)
{
  exp_ = other.exp_->clone();

}

EKWMean &EKWMean::operator=(const EKWMean & other)
{
  EKWMean tmp(other);
  swap(tmp);
  return *this;
}

void EKWMean::swap(EKWMean & other)
{
  std::swap(exp_, other.exp_);

}

EKWMean::~EKWMean()
{
  delete(exp_);

}

void EKWMean::accept(Visitor *v)
{
  v->visitEKWMean(this);
}

EKWMean *EKWMean::clone() const
{
  return new EKWMean(*this);
}



/********************   EKWSqrt    ********************/
EKWSqrt::EKWSqrt(Exp *p1)
{
  exp_ = p1;

}

EKWSqrt::EKWSqrt(const EKWSqrt & other)
{
  exp_ = other.exp_->clone();

}

EKWSqrt &EKWSqrt::operator=(const EKWSqrt & other)
{
  EKWSqrt tmp(other);
  swap(tmp);
  return *this;
}

void EKWSqrt::swap(EKWSqrt & other)
{
  std::swap(exp_, other.exp_);

}

EKWSqrt::~EKWSqrt()
{
  delete(exp_);

}

void EKWSqrt::accept(Visitor *v)
{
  v->visitEKWSqrt(this);
}

EKWSqrt *EKWSqrt::clone() const
{
  return new EKWSqrt(*this);
}



/********************   EKWFloor    ********************/
EKWFloor::EKWFloor(Exp *p1)
{
  exp_ = p1;

}

EKWFloor::EKWFloor(const EKWFloor & other)
{
  exp_ = other.exp_->clone();

}

EKWFloor &EKWFloor::operator=(const EKWFloor & other)
{
  EKWFloor tmp(other);
  swap(tmp);
  return *this;
}

void EKWFloor::swap(EKWFloor & other)
{
  std::swap(exp_, other.exp_);

}

EKWFloor::~EKWFloor()
{
  delete(exp_);

}

void EKWFloor::accept(Visitor *v)
{
  v->visitEKWFloor(this);
}

EKWFloor *EKWFloor::clone() const
{
  return new EKWFloor(*this);
}



/********************   EKWCeil    ********************/
EKWCeil::EKWCeil(Exp *p1)
{
  exp_ = p1;

}

EKWCeil::EKWCeil(const EKWCeil & other)
{
  exp_ = other.exp_->clone();

}

EKWCeil &EKWCeil::operator=(const EKWCeil & other)
{
  EKWCeil tmp(other);
  swap(tmp);
  return *this;
}

void EKWCeil::swap(EKWCeil & other)
{
  std::swap(exp_, other.exp_);

}

EKWCeil::~EKWCeil()
{
  delete(exp_);

}

void EKWCeil::accept(Visitor *v)
{
  v->visitEKWCeil(this);
}

EKWCeil *EKWCeil::clone() const
{
  return new EKWCeil(*this);
}



/********************   EKWRound    ********************/
EKWRound::EKWRound(Exp *p1)
{
  exp_ = p1;

}

EKWRound::EKWRound(const EKWRound & other)
{
  exp_ = other.exp_->clone();

}

EKWRound &EKWRound::operator=(const EKWRound & other)
{
  EKWRound tmp(other);
  swap(tmp);
  return *this;
}

void EKWRound::swap(EKWRound & other)
{
  std::swap(exp_, other.exp_);

}

EKWRound::~EKWRound()
{
  delete(exp_);

}

void EKWRound::accept(Visitor *v)
{
  v->visitEKWRound(this);
}

EKWRound *EKWRound::clone() const
{
  return new EKWRound(*this);
}



/********************   EKWTrunc    ********************/
EKWTrunc::EKWTrunc(Exp *p1)
{
  exp_ = p1;

}

EKWTrunc::EKWTrunc(const EKWTrunc & other)
{
  exp_ = other.exp_->clone();

}

EKWTrunc &EKWTrunc::operator=(const EKWTrunc & other)
{
  EKWTrunc tmp(other);
  swap(tmp);
  return *this;
}

void EKWTrunc::swap(EKWTrunc & other)
{
  std::swap(exp_, other.exp_);

}

EKWTrunc::~EKWTrunc()
{
  delete(exp_);

}

void EKWTrunc::accept(Visitor *v)
{
  v->visitEKWTrunc(this);
}

EKWTrunc *EKWTrunc::clone() const
{
  return new EKWTrunc(*this);
}



/********************   EKWAcc    ********************/
EKWAcc::EKWAcc(Exp *p1, VarIdent p2)
{
  exp_ = p1;
  varident_ = p2;

}

EKWAcc::EKWAcc(const EKWAcc & other)
{
  exp_ = other.exp_->clone();
  varident_ = other.varident_;

}

EKWAcc &EKWAcc::operator=(const EKWAcc & other)
{
  EKWAcc tmp(other);
  swap(tmp);
  return *this;
}

void EKWAcc::swap(EKWAcc & other)
{
  std::swap(exp_, other.exp_);
  std::swap(varident_, other.varident_);

}

EKWAcc::~EKWAcc()
{
  delete(exp_);

}

void EKWAcc::accept(Visitor *v)
{
  v->visitEKWAcc(this);
}

EKWAcc *EKWAcc::clone() const
{
  return new EKWAcc(*this);
}



/********************   PredAnd    ********************/
PredAnd::PredAnd(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredAnd::PredAnd(const PredAnd & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredAnd &PredAnd::operator=(const PredAnd & other)
{
  PredAnd tmp(other);
  swap(tmp);
  return *this;
}

void PredAnd::swap(PredAnd & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredAnd::~PredAnd()
{
  delete(pred_1);
  delete(pred_2);

}

void PredAnd::accept(Visitor *v)
{
  v->visitPredAnd(this);
}

PredAnd *PredAnd::clone() const
{
  return new PredAnd(*this);
}



/********************   PredOr    ********************/
PredOr::PredOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredOr::PredOr(const PredOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredOr &PredOr::operator=(const PredOr & other)
{
  PredOr tmp(other);
  swap(tmp);
  return *this;
}

void PredOr::swap(PredOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredOr::~PredOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredOr::accept(Visitor *v)
{
  v->visitPredOr(this);
}

PredOr *PredOr::clone() const
{
  return new PredOr(*this);
}



/********************   PredXOr    ********************/
PredXOr::PredXOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredXOr::PredXOr(const PredXOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredXOr &PredXOr::operator=(const PredXOr & other)
{
  PredXOr tmp(other);
  swap(tmp);
  return *this;
}

void PredXOr::swap(PredXOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredXOr::~PredXOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredXOr::accept(Visitor *v)
{
  v->visitPredXOr(this);
}

PredXOr *PredXOr::clone() const
{
  return new PredXOr(*this);
}



/********************   PredEQ    ********************/
PredEQ::PredEQ(Val *p1)
{
  val_ = p1;

}

PredEQ::PredEQ(const PredEQ & other)
{
  val_ = other.val_->clone();

}

PredEQ &PredEQ::operator=(const PredEQ & other)
{
  PredEQ tmp(other);
  swap(tmp);
  return *this;
}

void PredEQ::swap(PredEQ & other)
{
  std::swap(val_, other.val_);

}

PredEQ::~PredEQ()
{
  delete(val_);

}

void PredEQ::accept(Visitor *v)
{
  v->visitPredEQ(this);
}

PredEQ *PredEQ::clone() const
{
  return new PredEQ(*this);
}



/********************   PredGT    ********************/
PredGT::PredGT(Val *p1)
{
  val_ = p1;

}

PredGT::PredGT(const PredGT & other)
{
  val_ = other.val_->clone();

}

PredGT &PredGT::operator=(const PredGT & other)
{
  PredGT tmp(other);
  swap(tmp);
  return *this;
}

void PredGT::swap(PredGT & other)
{
  std::swap(val_, other.val_);

}

PredGT::~PredGT()
{
  delete(val_);

}

void PredGT::accept(Visitor *v)
{
  v->visitPredGT(this);
}

PredGT *PredGT::clone() const
{
  return new PredGT(*this);
}



/********************   PredLT    ********************/
PredLT::PredLT(Val *p1)
{
  val_ = p1;

}

PredLT::PredLT(const PredLT & other)
{
  val_ = other.val_->clone();

}

PredLT &PredLT::operator=(const PredLT & other)
{
  PredLT tmp(other);
  swap(tmp);
  return *this;
}

void PredLT::swap(PredLT & other)
{
  std::swap(val_, other.val_);

}

PredLT::~PredLT()
{
  delete(val_);

}

void PredLT::accept(Visitor *v)
{
  v->visitPredLT(this);
}

PredLT *PredLT::clone() const
{
  return new PredLT(*this);
}



/********************   PredGTEq    ********************/
PredGTEq::PredGTEq(Val *p1)
{
  val_ = p1;

}

PredGTEq::PredGTEq(const PredGTEq & other)
{
  val_ = other.val_->clone();

}

PredGTEq &PredGTEq::operator=(const PredGTEq & other)
{
  PredGTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredGTEq::swap(PredGTEq & other)
{
  std::swap(val_, other.val_);

}

PredGTEq::~PredGTEq()
{
  delete(val_);

}

void PredGTEq::accept(Visitor *v)
{
  v->visitPredGTEq(this);
}

PredGTEq *PredGTEq::clone() const
{
  return new PredGTEq(*this);
}



/********************   PredLTEq    ********************/
PredLTEq::PredLTEq(Val *p1)
{
  val_ = p1;

}

PredLTEq::PredLTEq(const PredLTEq & other)
{
  val_ = other.val_->clone();

}

PredLTEq &PredLTEq::operator=(const PredLTEq & other)
{
  PredLTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredLTEq::swap(PredLTEq & other)
{
  std::swap(val_, other.val_);

}

PredLTEq::~PredLTEq()
{
  delete(val_);

}

void PredLTEq::accept(Visitor *v)
{
  v->visitPredLTEq(this);
}

PredLTEq *PredLTEq::clone() const
{
  return new PredLTEq(*this);
}



/********************   PredNot    ********************/
PredNot::PredNot(Pred *p1)
{
  pred_ = p1;

}

PredNot::PredNot(const PredNot & other)
{
  pred_ = other.pred_->clone();

}

PredNot &PredNot::operator=(const PredNot & other)
{
  PredNot tmp(other);
  swap(tmp);
  return *this;
}

void PredNot::swap(PredNot & other)
{
  std::swap(pred_, other.pred_);

}

PredNot::~PredNot()
{
  delete(pred_);

}

void PredNot::accept(Visitor *v)
{
  v->visitPredNot(this);
}

PredNot *PredNot::clone() const
{
  return new PredNot(*this);
}



/********************   PredIsStr    ********************/
PredIsStr::PredIsStr()
{

}

PredIsStr::PredIsStr(const PredIsStr & other)
{

}

PredIsStr &PredIsStr::operator=(const PredIsStr & other)
{
  PredIsStr tmp(other);
  swap(tmp);
  return *this;
}

void PredIsStr::swap(PredIsStr & other)
{

}

PredIsStr::~PredIsStr()
{

}

void PredIsStr::accept(Visitor *v)
{
  v->visitPredIsStr(this);
}

PredIsStr *PredIsStr::clone() const
{
  return new PredIsStr(*this);
}



/********************   PredIsInt    ********************/
PredIsInt::PredIsInt()
{

}

PredIsInt::PredIsInt(const PredIsInt & other)
{

}

PredIsInt &PredIsInt::operator=(const PredIsInt & other)
{
  PredIsInt tmp(other);
  swap(tmp);
  return *this;
}

void PredIsInt::swap(PredIsInt & other)
{

}

PredIsInt::~PredIsInt()
{

}

void PredIsInt::accept(Visitor *v)
{
  v->visitPredIsInt(this);
}

PredIsInt *PredIsInt::clone() const
{
  return new PredIsInt(*this);
}



/********************   PredIsFloat    ********************/
PredIsFloat::PredIsFloat()
{

}

PredIsFloat::PredIsFloat(const PredIsFloat & other)
{

}

PredIsFloat &PredIsFloat::operator=(const PredIsFloat & other)
{
  PredIsFloat tmp(other);
  swap(tmp);
  return *this;
}

void PredIsFloat::swap(PredIsFloat & other)
{

}

PredIsFloat::~PredIsFloat()
{

}

void PredIsFloat::accept(Visitor *v)
{
  v->visitPredIsFloat(this);
}

PredIsFloat *PredIsFloat::clone() const
{
  return new PredIsFloat(*this);
}



/********************   PredInd    ********************/
PredInd::PredInd(Exp *p1)
{
  exp_ = p1;

}

PredInd::PredInd(const PredInd & other)
{
  exp_ = other.exp_->clone();

}

PredInd &PredInd::operator=(const PredInd & other)
{
  PredInd tmp(other);
  swap(tmp);
  return *this;
}

void PredInd::swap(PredInd & other)
{
  std::swap(exp_, other.exp_);

}

PredInd::~PredInd()
{
  delete(exp_);

}

void PredInd::accept(Visitor *v)
{
  v->visitPredInd(this);
}

PredInd *PredInd::clone() const
{
  return new PredInd(*this);
}



/********************   SVarAs    ********************/
SVarAs::SVarAs(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarAs::SVarAs(const SVarAs & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarAs &SVarAs::operator=(const SVarAs & other)
{
  SVarAs tmp(other);
  swap(tmp);
  return *this;
}

void SVarAs::swap(SVarAs & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarAs::~SVarAs()
{
  delete(exp_);

}

void SVarAs::accept(Visitor *v)
{
  v->visitSVarAs(this);
}

SVarAs *SVarAs::clone() const
{
  return new SVarAs(*this);
}



/********************   SVarAdd    ********************/
SVarAdd::SVarAdd(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarAdd::SVarAdd(const SVarAdd & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarAdd &SVarAdd::operator=(const SVarAdd & other)
{
  SVarAdd tmp(other);
  swap(tmp);
  return *this;
}

void SVarAdd::swap(SVarAdd & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarAdd::~SVarAdd()
{
  delete(exp_);

}

void SVarAdd::accept(Visitor *v)
{
  v->visitSVarAdd(this);
}

SVarAdd *SVarAdd::clone() const
{
  return new SVarAdd(*this);
}



/********************   SVarSub    ********************/
SVarSub::SVarSub(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarSub::SVarSub(const SVarSub & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarSub &SVarSub::operator=(const SVarSub & other)
{
  SVarSub tmp(other);
  swap(tmp);
  return *this;
}

void SVarSub::swap(SVarSub & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarSub::~SVarSub()
{
  delete(exp_);

}

void SVarSub::accept(Visitor *v)
{
  v->visitSVarSub(this);
}

SVarSub *SVarSub::clone() const
{
  return new SVarSub(*this);
}



/********************   SVarMul    ********************/
SVarMul::SVarMul(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarMul::SVarMul(const SVarMul & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarMul &SVarMul::operator=(const SVarMul & other)
{
  SVarMul tmp(other);
  swap(tmp);
  return *this;
}

void SVarMul::swap(SVarMul & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarMul::~SVarMul()
{
  delete(exp_);

}

void SVarMul::accept(Visitor *v)
{
  v->visitSVarMul(this);
}

SVarMul *SVarMul::clone() const
{
  return new SVarMul(*this);
}



/********************   SVarDiv    ********************/
SVarDiv::SVarDiv(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarDiv::SVarDiv(const SVarDiv & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarDiv &SVarDiv::operator=(const SVarDiv & other)
{
  SVarDiv tmp(other);
  swap(tmp);
  return *this;
}

void SVarDiv::swap(SVarDiv & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarDiv::~SVarDiv()
{
  delete(exp_);

}

void SVarDiv::accept(Visitor *v)
{
  v->visitSVarDiv(this);
}

SVarDiv *SVarDiv::clone() const
{
  return new SVarDiv(*this);
}



/********************   SFunDef    ********************/
SFunDef::SFunDef(VarIdent p1, ListExp *p2, Exp *p3)
{
  varident_ = p1;
  listexp_ = p2;
  exp_ = p3;

}

SFunDef::SFunDef(const SFunDef & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();
  exp_ = other.exp_->clone();

}

SFunDef &SFunDef::operator=(const SFunDef & other)
{
  SFunDef tmp(other);
  swap(tmp);
  return *this;
}

void SFunDef::swap(SFunDef & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);
  std::swap(exp_, other.exp_);

}

SFunDef::~SFunDef()
{
  delete(listexp_);
  delete(exp_);

}

void SFunDef::accept(Visitor *v)
{
  v->visitSFunDef(this);
}

SFunDef *SFunDef::clone() const
{
  return new SFunDef(*this);
}




/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListPred    ********************/

void ListPred::accept(Visitor *v)
{
  v->visitListPred(this);
}


ListPred *ListPred::clone() const
{
  return new ListPred(*this);
}




