//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   ExpCmd    ********************/
ExpCmd::ExpCmd(Exp *p1)
{
  exp_ = p1;

}

ExpCmd::ExpCmd(const ExpCmd & other)
{
  exp_ = other.exp_->clone();

}

ExpCmd &ExpCmd::operator=(const ExpCmd & other)
{
  ExpCmd tmp(other);
  swap(tmp);
  return *this;
}

void ExpCmd::swap(ExpCmd & other)
{
  std::swap(exp_, other.exp_);

}

ExpCmd::~ExpCmd()
{
  delete(exp_);

}

void ExpCmd::accept(Visitor *v)
{
  v->visitExpCmd(this);
}

ExpCmd *ExpCmd::clone() const
{
  return new ExpCmd(*this);
}



/********************   StmtCmd    ********************/
StmtCmd::StmtCmd(Stmt *p1)
{
  stmt_ = p1;

}

StmtCmd::StmtCmd(const StmtCmd & other)
{
  stmt_ = other.stmt_->clone();

}

StmtCmd &StmtCmd::operator=(const StmtCmd & other)
{
  StmtCmd tmp(other);
  swap(tmp);
  return *this;
}

void StmtCmd::swap(StmtCmd & other)
{
  std::swap(stmt_, other.stmt_);

}

StmtCmd::~StmtCmd()
{
  delete(stmt_);

}

void StmtCmd::accept(Visitor *v)
{
  v->visitStmtCmd(this);
}

StmtCmd *StmtCmd::clone() const
{
  return new StmtCmd(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EVal    ********************/
EVal::EVal(Val *p1)
{
  val_ = p1;

}

EVal::EVal(const EVal & other)
{
  val_ = other.val_->clone();

}

EVal &EVal::operator=(const EVal & other)
{
  EVal tmp(other);
  swap(tmp);
  return *this;
}

void EVal::swap(EVal & other)
{
  std::swap(val_, other.val_);

}

EVal::~EVal()
{
  delete(val_);

}

void EVal::accept(Visitor *v)
{
  v->visitEVal(this);
}

EVal *EVal::clone() const
{
  return new EVal(*this);
}



/********************   ESeq    ********************/
ESeq::ESeq(ExpSeq *p1)
{
  expseq_ = p1;

}

ESeq::ESeq(const ESeq & other)
{
  expseq_ = other.expseq_->clone();

}

ESeq &ESeq::operator=(const ESeq & other)
{
  ESeq tmp(other);
  swap(tmp);
  return *this;
}

void ESeq::swap(ESeq & other)
{
  std::swap(expseq_, other.expseq_);

}

ESeq::~ESeq()
{
  delete(expseq_);

}

void ESeq::accept(Visitor *v)
{
  v->visitESeq(this);
}

ESeq *ESeq::clone() const
{
  return new ESeq(*this);
}



/********************   EDice    ********************/
EDice::EDice(ExpD *p1)
{
  expd_ = p1;

}

EDice::EDice(const EDice & other)
{
  expd_ = other.expd_->clone();

}

EDice &EDice::operator=(const EDice & other)
{
  EDice tmp(other);
  swap(tmp);
  return *this;
}

void EDice::swap(EDice & other)
{
  std::swap(expd_, other.expd_);

}

EDice::~EDice()
{
  delete(expd_);

}

void EDice::accept(Visitor *v)
{
  v->visitEDice(this);
}

EDice *EDice::clone() const
{
  return new EDice(*this);
}



/********************   EKeyW    ********************/
EKeyW::EKeyW(ExpKW *p1)
{
  expkw_ = p1;

}

EKeyW::EKeyW(const EKeyW & other)
{
  expkw_ = other.expkw_->clone();

}

EKeyW &EKeyW::operator=(const EKeyW & other)
{
  EKeyW tmp(other);
  swap(tmp);
  return *this;
}

void EKeyW::swap(EKeyW & other)
{
  std::swap(expkw_, other.expkw_);

}

EKeyW::~EKeyW()
{
  delete(expkw_);

}

void EKeyW::accept(Visitor *v)
{
  v->visitEKeyW(this);
}

EKeyW *EKeyW::clone() const
{
  return new EKeyW(*this);
}



/********************   ESeqFilt    ********************/
ESeqFilt::ESeqFilt(Exp *p1, Pred *p2)
{
  exp_ = p1;
  pred_ = p2;

}

ESeqFilt::ESeqFilt(const ESeqFilt & other)
{
  exp_ = other.exp_->clone();
  pred_ = other.pred_->clone();

}

ESeqFilt &ESeqFilt::operator=(const ESeqFilt & other)
{
  ESeqFilt tmp(other);
  swap(tmp);
  return *this;
}

void ESeqFilt::swap(ESeqFilt & other)
{
  std::swap(exp_, other.exp_);
  std::swap(pred_, other.pred_);

}

ESeqFilt::~ESeqFilt()
{
  delete(exp_);
  delete(pred_);

}

void ESeqFilt::accept(Visitor *v)
{
  v->visitESeqFilt(this);
}

ESeqFilt *ESeqFilt::clone() const
{
  return new ESeqFilt(*this);
}



/********************   ECall    ********************/
ECall::ECall(VarIdent p1, ListExp *p2)
{
  varident_ = p1;
  listexp_ = p2;

}

ECall::ECall(const ECall & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();

}

ECall &ECall::operator=(const ECall & other)
{
  ECall tmp(other);
  swap(tmp);
  return *this;
}

void ECall::swap(ECall & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);

}

ECall::~ECall()
{
  delete(listexp_);

}

void ECall::accept(Visitor *v)
{
  v->visitECall(this);
}

ECall *ECall::clone() const
{
  return new ECall(*this);
}



/********************   IntNum    ********************/
IntNum::IntNum(Integer p1)
{
  integer_ = p1;

}

IntNum::IntNum(const IntNum & other)
{
  integer_ = other.integer_;

}

IntNum &IntNum::operator=(const IntNum & other)
{
  IntNum tmp(other);
  swap(tmp);
  return *this;
}

void IntNum::swap(IntNum & other)
{
  std::swap(integer_, other.integer_);

}

IntNum::~IntNum()
{

}

void IntNum::accept(Visitor *v)
{
  v->visitIntNum(this);
}

IntNum *IntNum::clone() const
{
  return new IntNum(*this);
}



/********************   IntNegNum    ********************/
IntNegNum::IntNegNum(Integer p1)
{
  integer_ = p1;

}

IntNegNum::IntNegNum(const IntNegNum & other)
{
  integer_ = other.integer_;

}

IntNegNum &IntNegNum::operator=(const IntNegNum & other)
{
  IntNegNum tmp(other);
  swap(tmp);
  return *this;
}

void IntNegNum::swap(IntNegNum & other)
{
  std::swap(integer_, other.integer_);

}

IntNegNum::~IntNegNum()
{

}

void IntNegNum::accept(Visitor *v)
{
  v->visitIntNegNum(this);
}

IntNegNum *IntNegNum::clone() const
{
  return new IntNegNum(*this);
}



/********************   ValNum    ********************/
ValNum::ValNum(Numeral *p1)
{
  numeral_ = p1;

}

ValNum::ValNum(const ValNum & other)
{
  numeral_ = other.numeral_->clone();

}

ValNum &ValNum::operator=(const ValNum & other)
{
  ValNum tmp(other);
  swap(tmp);
  return *this;
}

void ValNum::swap(ValNum & other)
{
  std::swap(numeral_, other.numeral_);

}

ValNum::~ValNum()
{
  delete(numeral_);

}

void ValNum::accept(Visitor *v)
{
  v->visitValNum(this);
}

ValNum *ValNum::clone() const
{
  return new ValNum(*this);
}



/********************   ValVar    ********************/
ValVar::ValVar(VarIdent p1)
{
  varident_ = p1;

}

ValVar::ValVar(const ValVar & other)
{
  varident_ = other.varident_;

}

ValVar &ValVar::operator=(const ValVar & other)
{
  ValVar tmp(other);
  swap(tmp);
  return *this;
}

void ValVar::swap(ValVar & other)
{
  std::swap(varident_, other.varident_);

}

ValVar::~ValVar()
{

}

void ValVar::accept(Visitor *v)
{
  v->visitValVar(this);
}

ValVar *ValVar::clone() const
{
  return new ValVar(*this);
}



/********************   ValStr    ********************/
ValStr::ValStr(String p1)
{
  string_ = p1;

}

ValStr::ValStr(const ValStr & other)
{
  string_ = other.string_;

}

ValStr &ValStr::operator=(const ValStr & other)
{
  ValStr tmp(other);
  swap(tmp);
  return *this;
}

void ValStr::swap(ValStr & other)
{
  std::swap(string_, other.string_);

}

ValStr::~ValStr()
{

}

void ValStr::accept(Visitor *v)
{
  v->visitValStr(this);
}

ValStr *ValStr::clone() const
{
  return new ValStr(*this);
}



/********************   ERange    ********************/
ERange::ERange(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ERange::ERange(const ERange & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ERange &ERange::operator=(const ERange & other)
{
  ERange tmp(other);
  swap(tmp);
  return *this;
}

void ERange::swap(ERange & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ERange::~ERange()
{
  delete(exp_1);
  delete(exp_2);

}

void ERange::accept(Visitor *v)
{
  v->visitERange(this);
}

ERange *ERange::clone() const
{
  return new ERange(*this);
}



/********************   ERStep    ********************/
ERStep::ERStep(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

ERStep::ERStep(const ERStep & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

ERStep &ERStep::operator=(const ERStep & other)
{
  ERStep tmp(other);
  swap(tmp);
  return *this;
}

void ERStep::swap(ERStep & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

ERStep::~ERStep()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void ERStep::accept(Visitor *v)
{
  v->visitERStep(this);
}

ERStep *ERStep::clone() const
{
  return new ERStep(*this);
}



/********************   EVect    ********************/
EVect::EVect(ListExp *p1)
{
  listexp_ = p1;

}

EVect::EVect(const EVect & other)
{
  listexp_ = other.listexp_->clone();

}

EVect &EVect::operator=(const EVect & other)
{
  EVect tmp(other);
  swap(tmp);
  return *this;
}

void EVect::swap(EVect & other)
{
  std::swap(listexp_, other.listexp_);

}

EVect::~EVect()
{
  delete(listexp_);

}

void EVect::accept(Visitor *v)
{
  v->visitEVect(this);
}

EVect *EVect::clone() const
{
  return new EVect(*this);
}



/********************   E1d6    ********************/
E1d6::E1d6()
{

}

E1d6::E1d6(const E1d6 & other)
{

}

E1d6 &E1d6::operator=(const E1d6 & other)
{
  E1d6 tmp(other);
  swap(tmp);
  return *this;
}

void E1d6::swap(E1d6 & other)
{

}

E1d6::~E1d6()
{

}

void E1d6::accept(Visitor *v)
{
  v->visitE1d6(this);
}

E1d6 *E1d6::clone() const
{
  return new E1d6(*this);
}



/********************   E1dN    ********************/
E1dN::E1dN(Exp *p1)
{
  exp_ = p1;

}

E1dN::E1dN(const E1dN & other)
{
  exp_ = other.exp_->clone();

}

E1dN &E1dN::operator=(const E1dN & other)
{
  E1dN tmp(other);
  swap(tmp);
  return *this;
}

void E1dN::swap(E1dN & other)
{
  std::swap(exp_, other.exp_);

}

E1dN::~E1dN()
{
  delete(exp_);

}

void E1dN::accept(Visitor *v)
{
  v->visitE1dN(this);
}

E1dN *E1dN::clone() const
{
  return new E1dN(*this);
}



/********************   ENd6    ********************/
ENd6::ENd6(Exp *p1)
{
  exp_ = p1;

}

ENd6::ENd6(const ENd6 & other)
{
  exp_ = other.exp_->clone();

}

ENd6 &ENd6::operator=(const ENd6 & other)
{
  ENd6 tmp(other);
  swap(tmp);
  return *this;
}

void ENd6::swap(ENd6 & other)
{
  std::swap(exp_, other.exp_);

}

ENd6::~ENd6()
{
  delete(exp_);

}

void ENd6::accept(Visitor *v)
{
  v->visitENd6(this);
}

ENd6 *ENd6::clone() const
{
  return new ENd6(*this);
}



/********************   ENdN    ********************/
ENdN::ENdN(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENdN::ENdN(const ENdN & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENdN &ENdN::operator=(const ENdN & other)
{
  ENdN tmp(other);
  swap(tmp);
  return *this;
}

void ENdN::swap(ENdN & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENdN::~ENdN()
{
  delete(exp_1);
  delete(exp_2);

}

void ENdN::accept(Visitor *v)
{
  v->visitENdN(this);
}

ENdN *ENdN::clone() const
{
  return new ENdN(*this);
}



/********************   EKCount    ********************/
EKCount::EKCount(Exp *p1)
{
  exp_ = p1;

}

EKCount::EKCount(const EKCount & other)
{
  exp_ = other.exp_->clone();

}

EKCount &EKCount::operator=(const EKCount & other)
{
  EKCount tmp(other);
  swap(tmp);
  return *this;
}

void EKCount::swap(EKCount & other)
{
  std::swap(exp_, other.exp_);

}

EKCount::~EKCount()
{
  delete(exp_);

}

void EKCount::accept(Visitor *v)
{
  v->visitEKCount(this);
}

EKCount *EKCount::clone() const
{
  return new EKCount(*this);
}



/********************   EKSum    ********************/
EKSum::EKSum(Exp *p1)
{
  exp_ = p1;

}

EKSum::EKSum(const EKSum & other)
{
  exp_ = other.exp_->clone();

}

EKSum &EKSum::operator=(const EKSum & other)
{
  EKSum tmp(other);
  swap(tmp);
  return *this;
}

void EKSum::swap(EKSum & other)
{
  std::swap(exp_, other.exp_);

}

EKSum::~EKSum()
{
  delete(exp_);

}

void EKSum::accept(Visitor *v)
{
  v->visitEKSum(this);
}

EKSum *EKSum::clone() const
{
  return new EKSum(*this);
}



/********************   EKRepeat    ********************/
EKRepeat::EKRepeat(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EKRepeat::EKRepeat(const EKRepeat & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EKRepeat &EKRepeat::operator=(const EKRepeat & other)
{
  EKRepeat tmp(other);
  swap(tmp);
  return *this;
}

void EKRepeat::swap(EKRepeat & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EKRepeat::~EKRepeat()
{
  delete(exp_1);
  delete(exp_2);

}

void EKRepeat::accept(Visitor *v)
{
  v->visitEKRepeat(this);
}

EKRepeat *EKRepeat::clone() const
{
  return new EKRepeat(*this);
}



/********************   EKMean    ********************/
EKMean::EKMean(Exp *p1)
{
  exp_ = p1;

}

EKMean::EKMean(const EKMean & other)
{
  exp_ = other.exp_->clone();

}

EKMean &EKMean::operator=(const EKMean & other)
{
  EKMean tmp(other);
  swap(tmp);
  return *this;
}

void EKMean::swap(EKMean & other)
{
  std::swap(exp_, other.exp_);

}

EKMean::~EKMean()
{
  delete(exp_);

}

void EKMean::accept(Visitor *v)
{
  v->visitEKMean(this);
}

EKMean *EKMean::clone() const
{
  return new EKMean(*this);
}



/********************   EKAcc    ********************/
EKAcc::EKAcc(Exp *p1, VarIdent p2)
{
  exp_ = p1;
  varident_ = p2;

}

EKAcc::EKAcc(const EKAcc & other)
{
  exp_ = other.exp_->clone();
  varident_ = other.varident_;

}

EKAcc &EKAcc::operator=(const EKAcc & other)
{
  EKAcc tmp(other);
  swap(tmp);
  return *this;
}

void EKAcc::swap(EKAcc & other)
{
  std::swap(exp_, other.exp_);
  std::swap(varident_, other.varident_);

}

EKAcc::~EKAcc()
{
  delete(exp_);

}

void EKAcc::accept(Visitor *v)
{
  v->visitEKAcc(this);
}

EKAcc *EKAcc::clone() const
{
  return new EKAcc(*this);
}



/********************   PredBranch    ********************/
PredBranch::PredBranch(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredBranch::PredBranch(const PredBranch & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredBranch &PredBranch::operator=(const PredBranch & other)
{
  PredBranch tmp(other);
  swap(tmp);
  return *this;
}

void PredBranch::swap(PredBranch & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredBranch::~PredBranch()
{
  delete(pred_1);
  delete(pred_2);

}

void PredBranch::accept(Visitor *v)
{
  v->visitPredBranch(this);
}

PredBranch *PredBranch::clone() const
{
  return new PredBranch(*this);
}



/********************   PredAnd    ********************/
PredAnd::PredAnd(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredAnd::PredAnd(const PredAnd & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredAnd &PredAnd::operator=(const PredAnd & other)
{
  PredAnd tmp(other);
  swap(tmp);
  return *this;
}

void PredAnd::swap(PredAnd & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredAnd::~PredAnd()
{
  delete(pred_1);
  delete(pred_2);

}

void PredAnd::accept(Visitor *v)
{
  v->visitPredAnd(this);
}

PredAnd *PredAnd::clone() const
{
  return new PredAnd(*this);
}



/********************   PredOr    ********************/
PredOr::PredOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredOr::PredOr(const PredOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredOr &PredOr::operator=(const PredOr & other)
{
  PredOr tmp(other);
  swap(tmp);
  return *this;
}

void PredOr::swap(PredOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredOr::~PredOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredOr::accept(Visitor *v)
{
  v->visitPredOr(this);
}

PredOr *PredOr::clone() const
{
  return new PredOr(*this);
}



/********************   PredXOr    ********************/
PredXOr::PredXOr(Pred *p1, Pred *p2)
{
  pred_1 = p1;
  pred_2 = p2;

}

PredXOr::PredXOr(const PredXOr & other)
{
  pred_1 = other.pred_1->clone();
  pred_2 = other.pred_2->clone();

}

PredXOr &PredXOr::operator=(const PredXOr & other)
{
  PredXOr tmp(other);
  swap(tmp);
  return *this;
}

void PredXOr::swap(PredXOr & other)
{
  std::swap(pred_1, other.pred_1);
  std::swap(pred_2, other.pred_2);

}

PredXOr::~PredXOr()
{
  delete(pred_1);
  delete(pred_2);

}

void PredXOr::accept(Visitor *v)
{
  v->visitPredXOr(this);
}

PredXOr *PredXOr::clone() const
{
  return new PredXOr(*this);
}



/********************   PredEQ    ********************/
PredEQ::PredEQ(Val *p1)
{
  val_ = p1;

}

PredEQ::PredEQ(const PredEQ & other)
{
  val_ = other.val_->clone();

}

PredEQ &PredEQ::operator=(const PredEQ & other)
{
  PredEQ tmp(other);
  swap(tmp);
  return *this;
}

void PredEQ::swap(PredEQ & other)
{
  std::swap(val_, other.val_);

}

PredEQ::~PredEQ()
{
  delete(val_);

}

void PredEQ::accept(Visitor *v)
{
  v->visitPredEQ(this);
}

PredEQ *PredEQ::clone() const
{
  return new PredEQ(*this);
}



/********************   PredNEQ    ********************/
PredNEQ::PredNEQ(Val *p1)
{
  val_ = p1;

}

PredNEQ::PredNEQ(const PredNEQ & other)
{
  val_ = other.val_->clone();

}

PredNEQ &PredNEQ::operator=(const PredNEQ & other)
{
  PredNEQ tmp(other);
  swap(tmp);
  return *this;
}

void PredNEQ::swap(PredNEQ & other)
{
  std::swap(val_, other.val_);

}

PredNEQ::~PredNEQ()
{
  delete(val_);

}

void PredNEQ::accept(Visitor *v)
{
  v->visitPredNEQ(this);
}

PredNEQ *PredNEQ::clone() const
{
  return new PredNEQ(*this);
}



/********************   PredGT    ********************/
PredGT::PredGT(Val *p1)
{
  val_ = p1;

}

PredGT::PredGT(const PredGT & other)
{
  val_ = other.val_->clone();

}

PredGT &PredGT::operator=(const PredGT & other)
{
  PredGT tmp(other);
  swap(tmp);
  return *this;
}

void PredGT::swap(PredGT & other)
{
  std::swap(val_, other.val_);

}

PredGT::~PredGT()
{
  delete(val_);

}

void PredGT::accept(Visitor *v)
{
  v->visitPredGT(this);
}

PredGT *PredGT::clone() const
{
  return new PredGT(*this);
}



/********************   PredLT    ********************/
PredLT::PredLT(Val *p1)
{
  val_ = p1;

}

PredLT::PredLT(const PredLT & other)
{
  val_ = other.val_->clone();

}

PredLT &PredLT::operator=(const PredLT & other)
{
  PredLT tmp(other);
  swap(tmp);
  return *this;
}

void PredLT::swap(PredLT & other)
{
  std::swap(val_, other.val_);

}

PredLT::~PredLT()
{
  delete(val_);

}

void PredLT::accept(Visitor *v)
{
  v->visitPredLT(this);
}

PredLT *PredLT::clone() const
{
  return new PredLT(*this);
}



/********************   PredGTEq    ********************/
PredGTEq::PredGTEq(Val *p1)
{
  val_ = p1;

}

PredGTEq::PredGTEq(const PredGTEq & other)
{
  val_ = other.val_->clone();

}

PredGTEq &PredGTEq::operator=(const PredGTEq & other)
{
  PredGTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredGTEq::swap(PredGTEq & other)
{
  std::swap(val_, other.val_);

}

PredGTEq::~PredGTEq()
{
  delete(val_);

}

void PredGTEq::accept(Visitor *v)
{
  v->visitPredGTEq(this);
}

PredGTEq *PredGTEq::clone() const
{
  return new PredGTEq(*this);
}



/********************   PredLTEq    ********************/
PredLTEq::PredLTEq(Val *p1)
{
  val_ = p1;

}

PredLTEq::PredLTEq(const PredLTEq & other)
{
  val_ = other.val_->clone();

}

PredLTEq &PredLTEq::operator=(const PredLTEq & other)
{
  PredLTEq tmp(other);
  swap(tmp);
  return *this;
}

void PredLTEq::swap(PredLTEq & other)
{
  std::swap(val_, other.val_);

}

PredLTEq::~PredLTEq()
{
  delete(val_);

}

void PredLTEq::accept(Visitor *v)
{
  v->visitPredLTEq(this);
}

PredLTEq *PredLTEq::clone() const
{
  return new PredLTEq(*this);
}



/********************   PredIsStr    ********************/
PredIsStr::PredIsStr(Val *p1)
{
  val_ = p1;

}

PredIsStr::PredIsStr(const PredIsStr & other)
{
  val_ = other.val_->clone();

}

PredIsStr &PredIsStr::operator=(const PredIsStr & other)
{
  PredIsStr tmp(other);
  swap(tmp);
  return *this;
}

void PredIsStr::swap(PredIsStr & other)
{
  std::swap(val_, other.val_);

}

PredIsStr::~PredIsStr()
{
  delete(val_);

}

void PredIsStr::accept(Visitor *v)
{
  v->visitPredIsStr(this);
}

PredIsStr *PredIsStr::clone() const
{
  return new PredIsStr(*this);
}



/********************   PredInd    ********************/
PredInd::PredInd(Val *p1)
{
  val_ = p1;

}

PredInd::PredInd(const PredInd & other)
{
  val_ = other.val_->clone();

}

PredInd &PredInd::operator=(const PredInd & other)
{
  PredInd tmp(other);
  swap(tmp);
  return *this;
}

void PredInd::swap(PredInd & other)
{
  std::swap(val_, other.val_);

}

PredInd::~PredInd()
{
  delete(val_);

}

void PredInd::accept(Visitor *v)
{
  v->visitPredInd(this);
}

PredInd *PredInd::clone() const
{
  return new PredInd(*this);
}



/********************   PredRange    ********************/
PredRange::PredRange(Val *p1, Val *p2)
{
  val_1 = p1;
  val_2 = p2;

}

PredRange::PredRange(const PredRange & other)
{
  val_1 = other.val_1->clone();
  val_2 = other.val_2->clone();

}

PredRange &PredRange::operator=(const PredRange & other)
{
  PredRange tmp(other);
  swap(tmp);
  return *this;
}

void PredRange::swap(PredRange & other)
{
  std::swap(val_1, other.val_1);
  std::swap(val_2, other.val_2);

}

PredRange::~PredRange()
{
  delete(val_1);
  delete(val_2);

}

void PredRange::accept(Visitor *v)
{
  v->visitPredRange(this);
}

PredRange *PredRange::clone() const
{
  return new PredRange(*this);
}



/********************   PredRStep    ********************/
PredRStep::PredRStep(Val *p1, Val *p2, Val *p3)
{
  val_1 = p1;
  val_2 = p2;
  val_3 = p3;

}

PredRStep::PredRStep(const PredRStep & other)
{
  val_1 = other.val_1->clone();
  val_2 = other.val_2->clone();
  val_3 = other.val_3->clone();

}

PredRStep &PredRStep::operator=(const PredRStep & other)
{
  PredRStep tmp(other);
  swap(tmp);
  return *this;
}

void PredRStep::swap(PredRStep & other)
{
  std::swap(val_1, other.val_1);
  std::swap(val_2, other.val_2);
  std::swap(val_3, other.val_3);

}

PredRStep::~PredRStep()
{
  delete(val_1);
  delete(val_2);
  delete(val_3);

}

void PredRStep::accept(Visitor *v)
{
  v->visitPredRStep(this);
}

PredRStep *PredRStep::clone() const
{
  return new PredRStep(*this);
}



/********************   SVarAs    ********************/
SVarAs::SVarAs(VarIdent p1, Exp *p2)
{
  varident_ = p1;
  exp_ = p2;

}

SVarAs::SVarAs(const SVarAs & other)
{
  varident_ = other.varident_;
  exp_ = other.exp_->clone();

}

SVarAs &SVarAs::operator=(const SVarAs & other)
{
  SVarAs tmp(other);
  swap(tmp);
  return *this;
}

void SVarAs::swap(SVarAs & other)
{
  std::swap(varident_, other.varident_);
  std::swap(exp_, other.exp_);

}

SVarAs::~SVarAs()
{
  delete(exp_);

}

void SVarAs::accept(Visitor *v)
{
  v->visitSVarAs(this);
}

SVarAs *SVarAs::clone() const
{
  return new SVarAs(*this);
}



/********************   SFDef    ********************/
SFDef::SFDef(VarIdent p1, ListExp *p2, Exp *p3)
{
  varident_ = p1;
  listexp_ = p2;
  exp_ = p3;

}

SFDef::SFDef(const SFDef & other)
{
  varident_ = other.varident_;
  listexp_ = other.listexp_->clone();
  exp_ = other.exp_->clone();

}

SFDef &SFDef::operator=(const SFDef & other)
{
  SFDef tmp(other);
  swap(tmp);
  return *this;
}

void SFDef::swap(SFDef & other)
{
  std::swap(varident_, other.varident_);
  std::swap(listexp_, other.listexp_);
  std::swap(exp_, other.exp_);

}

SFDef::~SFDef()
{
  delete(listexp_);
  delete(exp_);

}

void SFDef::accept(Visitor *v)
{
  v->visitSFDef(this);
}

SFDef *SFDef::clone() const
{
  return new SFDef(*this);
}




/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}




