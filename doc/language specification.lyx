#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
mrZalli
\end_layout

\begin_layout Title
Roller language specification draft
\end_layout

\begin_layout Standard
This is the first draft of the language for the interactive parser 
\begin_inset CommandInset href
LatexCommand href
name "Roller"
target "https://github.com/mrZalli/Roller"

\end_inset

.
 No fully functional parser exists yet.
\end_layout

\begin_layout Section
Values
\end_layout

\begin_layout Standard
The program can operate on a limited set of built-in types.
 These types can be put into list types.
\end_layout

\begin_layout Subsection
Single values
\end_layout

\begin_layout Standard
There are two different types of values: numerals and strings.
 Numerals can further be split into integers and reals (floating point).
 Single values can be implicitly converted to single value lists.
\end_layout

\begin_layout Itemize
Numeral
\end_layout

\begin_deeper
\begin_layout Itemize
Behaves like numeral types in other languages.
 A list of digits or a floating point value.
\end_layout

\begin_layout Itemize
If in a mathematical operation any of the operands are real numbers, the
 result is a real.
\end_layout

\begin_layout Itemize
If in a mathematical operation both of the operands are integers, then the
 result is an integer, except in division where the result is a real.
\end_layout

\end_deeper
\begin_layout Itemize
String
\end_layout

\begin_deeper
\begin_layout Itemize
From mathemathical operations, only addition operation is allowed for strings.
\end_layout

\begin_deeper
\begin_layout Itemize
Addition concatenates two strings, or an string and a numeral
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Lists are values inside curly brackets and separated by commas.
 For example: 
\begin_inset Formula $\left\{ a,\, b,\, c,\, d,\, e\right\} $
\end_inset

.
 A list can have lists as members, called child-lists.
\end_layout

\begin_layout Subsubsection
List operators
\end_layout

\begin_layout Standard
Operations meant for single values are applied recursively on every list
 member separately when used on lists.
 Lists can be implicitly converted to single values, which calls the lists
 sum.
\end_layout

\begin_layout Subsubsection
Ranges
\end_layout

\begin_layout Standard
Ranges are flat numeral lists that start from the start value and end on
 the end value, with each consecutive value incrementing or decrementing
 by the step value until the end value is reached.
\end_layout

\begin_layout Standard
Ranges are defined with 
\begin_inset Formula $start,next..end$
\end_inset

 where 
\begin_inset Formula $start$
\end_inset

 is the initial value, 
\begin_inset Formula $end$
\end_inset

 is the last value and 
\begin_inset Formula $next$
\end_inset

 is the initial value plus the step value.
 Depending on the step value, the range might not contain the 
\begin_inset Formula $end$
\end_inset

 value, but it will never contain any value with a greater absolute value
 than 
\begin_inset Formula $end$
\end_inset

.
\end_layout

\begin_layout Standard
If the 
\begin_inset Formula $next$
\end_inset

 parameter is omitted, eg.
 
\begin_inset Formula $start..end$
\end_inset

, a step value of +1 or -1 is assumed depending whether 
\begin_inset Formula $start$
\end_inset

 is lesser than 
\begin_inset Formula $end$
\end_inset

 or not.
 If the 
\begin_inset Formula $end$
\end_inset

 parameter is omitted, the range is infinite, but trying to access it's
 last value raises an error 
\series bold
or
\series default
 causes undefined behaviour.
\end_layout

\begin_layout Standard
If the step value has the wrong sign (eg.
 
\begin_inset Formula $0,4..\left(-12\right)$
\end_inset

) an error is raised.
\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Standard
A variable can hold any value.
 Variable identifier is recognized by the regular expression 
\begin_inset Formula $\left(\,[a-zA-Z]\,|\,\_\,\right)$
\end_inset

, so they can contain only letters and underscores.
\end_layout

\begin_layout Standard
Variables are stored in the environment and to change them you need to use
 statements.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
Functions are repeatable expressions with a zero or more parameters.
 Functions always return a value, or cause an error.
\end_layout

\begin_layout Standard
Parameter is the function's local variable, while argument is the value
 given to the parameter on function call.
 Variables and function names must be unique.
\end_layout

\begin_layout Subsubsection
Parameters
\end_layout

\begin_layout Standard
By default all variables are in the global namespace, but functions can
 define parameter variables that are in the function's namespace.
\end_layout

\begin_layout Standard
If there is a function parameter with the same name as a global variable,
 the parameter hides the global variable.
 No type checking is done to the arguments put into parameters.
\end_layout

\begin_layout Section
Commands
\end_layout

\begin_layout Standard
The Roller application takes commands as an input.
 There are two types of commands: expressions and statements.
\end_layout

\begin_layout Standard
Expressions return a value and don't cause side-effects, while statements
 don't return a value and cause side-effects.
 If the command is an expression, it's return value is printed.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
All expressions must return a value except if the expression encounters
 an error.
\end_layout

\begin_layout Standard
In that case, the execution of the command the expression was in, must be
 stopped and the user should be informed.
\end_layout

\begin_layout Subsubsection
Expression types
\end_layout

\begin_layout Itemize
Value expression
\end_layout

\begin_deeper
\begin_layout Itemize
This constructs a value
\end_layout

\begin_layout Itemize
Value can be a single value or a list.
\end_layout

\begin_layout Itemize
The value types are defined in the part 1
\end_layout

\end_deeper
\begin_layout Itemize
Dice expressions
\end_layout

\begin_deeper
\begin_layout Itemize
An expression that represents dice throw with multiple similar die.
\end_layout

\begin_layout Itemize
Uses the dice notation, so 
\begin_inset Formula $N\mbox{d}M$
\end_inset

 means throw N amount of M sided die, if both N and M are integers.
 If the parameters are not present the defaults are used.
\end_layout

\begin_deeper
\begin_layout Itemize
By default the amount is 1 and the sides are 6, so 
\begin_inset Formula $\mbox{d}$
\end_inset

 equals to 
\begin_inset Formula $1\mbox{d}6$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
If the sides parameter is a list, then each of the dice face is one of the
 list members.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $1\mbox{d}\left\{ "heads",\,"tails"\right\} $
\end_inset

 either gives the string 
\begin_inset Formula $"heads"$
\end_inset

 or the string 
\begin_inset Formula $"tails"$
\end_inset

 as the result.
\end_layout

\end_deeper
\begin_layout Itemize
If the amount parameter is a list of integers, then the expression returns
 a list where each list member is a list of that many dice throws as the
 corresponding parameter integer.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left\{ 2,\,4,\,3\right\} \mbox{d}6$
\end_inset

 is equivalent to 
\begin_inset Formula $\left\{ 2\mbox{d}6,\,4\mbox{d}6,\,3\mbox{d}6\right\} $
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Mathemathical operators
\end_layout

\begin_deeper
\begin_layout Itemize
All mathematical operators are infix, except the negation operator.
\end_layout

\begin_layout Itemize
All operators behave normally between single values (scalars)
\end_layout

\begin_layout Itemize
If one of the operands is a liste and the another is a single value, then
 the operation is applied to the every element on the list recurisvely
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $a+\left\{ b,\, c\right\} \rightarrow\left\{ a+b,\, a+c\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If both of the operands are lists then the operator is applied between each
 element.
 If another list is longer than another, then the remaining elements are
 ignored.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left\{ a,\, b,\, c\right\} *\left\{ d,\, e\right\} \rightarrow\left\{ a*d,\, b*e\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Keyword expressions
\end_layout

\begin_deeper
\begin_layout Itemize
All keywords start with a capital letter followed by non-capital or capital
 letters
\end_layout

\begin_layout Itemize
All keyword expressions consist of a keyword and the parameters.
 The keyword is always before the parameters
\end_layout

\begin_layout Itemize
Unlike functions, keyword expression's arguments are not surrounded by parenthes
es.
\end_layout

\begin_layout Itemize
The different keywords and their functions are defined in 2.1.2
\end_layout

\end_deeper
\begin_layout Itemize
Namespace calls
\end_layout

\begin_deeper
\begin_layout Itemize
To use the value of a variable write it's name.
 If there is no variable with that name an error is given.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $foo+1$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To call a function write it's name, followed by it's arguments, if any,
 in parenthesis.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $foo(1,6)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
List filtering expression
\end_layout

\begin_deeper
\begin_layout Itemize
The lists can be filtered with the filtering expression.
\end_layout

\begin_layout Itemize
The filtering expression consists of the filtered expression and the predicate
 in square brackets.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $Count\,8\mbox{d}6[>=5]$
\end_inset

 counts all the dice throws that were five or six.
\end_layout

\end_deeper
\begin_layout Itemize
Returns a list of the members that fit the for each of the predicates in
 the list.
\end_layout

\begin_layout Itemize
Filtering considers the list to be flat and the filtering is not done to
 the members of the child lists.
\end_layout

\begin_layout Itemize
The different predicates are defined in the part 3
\end_layout

\end_deeper
\begin_layout Subsubsection
Different operator and keyword expressions
\end_layout

\begin_layout Itemize
Mathemathical operators (precedence is as expected)
\end_layout

\begin_deeper
\begin_layout Itemize
Addition/String concatenation (
\begin_inset Formula $a+b$
\end_inset

) 
\end_layout

\begin_layout Itemize
Substraction (
\begin_inset Formula $a-b$
\end_inset

)
\end_layout

\begin_layout Itemize
Multiplication (
\begin_inset Formula $a*b$
\end_inset

)
\end_layout

\begin_layout Itemize
Division (
\begin_inset Formula $a/b$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Result is a real numeral.
\end_layout

\end_deeper
\begin_layout Itemize
Exponent (
\begin_inset Formula $a\mathcircumflex b$
\end_inset

)
\end_layout

\begin_layout Itemize
Negation (
\begin_inset Formula $-a$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Note: 
\begin_inset Formula $-a\mathcircumflex b$
\end_inset

 means 
\begin_inset Formula $-\left(a\mathcircumflex b\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Keyword expressions
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Count\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Gives the length of a list.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Sum\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Gives the sum of a list
\end_layout

\begin_layout Itemize
If any of the members are a string, the sum is all of the values converted
 to strings and concatenated with spaces between.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Mean\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\begin_layout Itemize
Returns the mean value of a numeral list.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Sqrt\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\begin_layout Itemize
Returns the square root of 
\begin_inset Formula $a$
\end_inset

 recursively
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Root\: n\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\begin_layout Itemize
Returns the 
\begin_inset Formula $n$
\end_inset

:th root of 
\begin_inset Formula $a$
\end_inset

 recursively
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $n$
\end_inset

 is a list return the roots for all it's lists recursively
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Repeat\: n\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Repeats the 
\begin_inset Formula $a$
\end_inset

 expression 
\begin_inset Formula $n$
\end_inset

 times and returns a list of the 
\begin_inset Formula $b$
\end_inset

's value for each repetition.
\end_layout

\begin_layout Itemize
The first parameter must be an integer or an integer list.
\end_layout

\begin_layout Itemize
If the first parameter is an integer list then the repeat is done for each
 of it's members recursively.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $Repeat\:\left\{ 3,\,2\right\} \:1\mbox{d}20$
\end_inset

 is equivalent to 
\begin_inset Formula $\left\{ Repeat\:3\:1\mbox{d}20,\, Repeat\:2\:1\mbox{d}20\right\} $
\end_inset

.
 It is also equivalent to 
\begin_inset Formula $\left\{ 3,\,2\right\} \mbox{d}20$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Formula $Acc\: function\: sequence$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Accumulates the 
\begin_inset Formula $function$
\end_inset

 over the 
\begin_inset Formula $sequence$
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $Acc\: add\:\left\{ 1,2,4,3\right\} $
\end_inset

, where 
\begin_inset Formula $add(a,\, b)=a+b$
\end_inset

, is equivalent to 
\begin_inset Formula $Sum\,\left\{ 1,2,4,3\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToString\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Returns a string representation of 
\begin_inset Formula $a$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToNumeral\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $a$
\end_inset

 is a string this returns it's numeral representation.
 If the string doesn't contain a numeral (integer or floating point) this
 generates an error
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $a$
\end_inset

 is a numeral list this returns it's sum
\end_layout

\begin_layout Itemize
Otherwise generates an error
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $SplitString\, a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined only for strings
\end_layout

\begin_layout Itemize
Converts the string 
\begin_inset Formula $a$
\end_inset

 to a list of letters
\end_layout

\begin_layout Itemize
The letters are single character strings
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Statements
\end_layout

\begin_layout Standard
Statements have side-effects, which means that they change the state of
 the environment, more specifically the namespace.
\end_layout

\begin_layout Subsubsection
Variable assignment statements
\end_layout

\begin_layout Itemize
Variable assignment, 
\begin_inset Formula $name=expression$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Creates or replaces a variable with the of 
\begin_inset Formula $name$
\end_inset

 with the evaluated value of 
\begin_inset Formula $expression$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Assignment and operation, 
\begin_inset Formula $+=$
\end_inset

, 
\begin_inset Formula $-=$
\end_inset

, 
\begin_inset Formula $*=$
\end_inset

, 
\begin_inset Formula $/=$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does the operation with the variable and the expression as operands and
 places the result into the variable.
\end_layout

\begin_layout Itemize
If the variable is not defined this raises an error
\end_layout

\end_deeper
\begin_layout Subsubsection
Function definition
\end_layout

\begin_layout Standard
Functions are defined like: 
\begin_inset Formula $name()=expression$
\end_inset

 or 
\begin_inset Formula $name(parameterList)=expression$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $parameterList$
\end_inset

 is a comma separated list of parameters, which are variables local to the
 function and assigned values on the function call.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $expression$
\end_inset

 is evaluated when the function is called.
\end_layout

\begin_layout Standard
Function and variable names should be unique and defining a function or
 variable with the same name as any existing function or variable raises
 an error.
\end_layout

\begin_layout Section
Predicates
\end_layout

\begin_layout Standard
Predicates define which values are passed through when filtering a list.
\end_layout

\begin_layout Standard
If there are multiple predicates, separated by commas, the filtering branches
 and it is done for all of the predicates and returned in a list.
\end_layout

\begin_layout Standard
List of the precedence levels different predicates have:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Precedence level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 1, lowest precedence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical connectives, except negation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparison predicates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 3, highest precedence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type predicates, indexing predicates, negation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Logical connectives
\end_layout

\begin_layout Standard
Logical connectives connect different predicates.
 Available connectives are:
\end_layout

\begin_layout Itemize
Conjunction/and, 
\begin_inset Formula $a\,\&\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff (if and only if) both of the operand predicates (
\begin_inset Formula $a$
\end_inset

, 
\series bold

\begin_inset Formula $b$
\end_inset

)
\series default
 are true.
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction/or, 
\begin_inset Formula $a\,|\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff any of the operands are true.
\end_layout

\end_deeper
\begin_layout Itemize
Exclusive disjunction/xor, 
\begin_inset Formula $a\,\mathcircumflex\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff one of the operands are true.
\end_layout

\end_deeper
\begin_layout Itemize
Negation/not, 
\begin_inset Formula $!a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff the operand is false.
\end_layout

\begin_layout Itemize
Has high precedence
\end_layout

\end_deeper
\begin_layout Subsection
Comparison predicates
\end_layout

\begin_layout Itemize
Equality, 
\begin_inset Formula $=a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Inequality can be achieved by combining the equality and negation predicates.
\end_layout

\end_deeper
\begin_layout Itemize
Comparison, 
\begin_inset Formula $<a$
\end_inset

, 
\begin_inset Formula $>a$
\end_inset

, 
\begin_inset Formula $<=a$
\end_inset

, 
\begin_inset Formula $>=a$
\end_inset


\end_layout

\begin_layout Subsection
Type predicates
\end_layout

\begin_layout Standard
These predicates hold true only for certain type of values
\end_layout

\begin_layout Itemize
Integer predicate, 
\begin_inset Formula $\#$
\end_inset


\end_layout

\begin_layout Itemize
Real predicate, 
\begin_inset Formula $\%$
\end_inset


\end_layout

\begin_layout Itemize
String predicate, 
\begin_inset Formula $\$$
\end_inset


\end_layout

\begin_layout Itemize
List predicate, 
\begin_inset Formula $\{\}$
\end_inset

, 
\begin_inset Formula $\{Predicate\}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Matches child lists
\end_layout

\begin_layout Itemize
The empty list predicate 
\begin_inset Formula $\{\}$
\end_inset

 matches any list.
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $Predicate$
\end_inset

 is almost any predicate that tells what kind of list we match.
 It must hold true for all of the members of the child list.
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Formula $Predicate$
\end_inset

 can't contain single values because that would be mixed with list indexing
 predicate (3.4)
\end_layout

\end_deeper
\begin_layout Itemize
Examples:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\{\#\}$
\end_inset

 matches integer lists
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{\#\,|\,\%\}$
\end_inset

 matches lists with integer and/or real values (numerals)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{\,!\{\}\,\}$
\end_inset

 matches lists that don't have any list members
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{<5\}$
\end_inset

 matches lists with only numeral variables that are smaller than five
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Indexing predicates
\end_layout

\begin_layout Standard
These predicates hold true only for a certain index or range of any list.
 They are normal expressions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Value$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Value$
\end_inset

 is not a list.
\end_layout

\begin_layout Itemize
Holds true only for the list member that is at the index 
\begin_inset Formula $Value$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $List$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Holds true for the values whose indexes are in the 
\begin_inset Formula $List$
\end_inset

.
\end_layout

\end_deeper
\end_body
\end_document
