#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
Zalli
\end_layout

\begin_layout Title
Roller language specification draft
\end_layout

\begin_layout Standard
This is a draft of the language for the interactive parser 
\begin_inset CommandInset href
LatexCommand href
name "Roller"
target "https://github.com/mrZalli/Roller"

\end_inset

.
 No fully functional parser exists yet.
 I'm sorry if this looks hard to understand since this is mainly meant for
 me to gather my thoughts.
\end_layout

\begin_layout Section
Values
\end_layout

\begin_layout Standard
The program can operate on a limited set of built-in types.
 These types can be put into lists.
\end_layout

\begin_layout Subsection
Single values
\end_layout

\begin_layout Standard
There are three different types of values: numerals, strings and errors.
 Numerals can further be split into integers and reals (floating point).
\end_layout

\begin_layout Standard
Single values can be implicitly converted to single value lists.
\end_layout

\begin_layout Itemize
Numeral
\end_layout

\begin_deeper
\begin_layout Itemize
An integer or real value.
\end_layout

\begin_layout Itemize
If in a mathematical operation any of the operands are real numbers, the
 result is a real.
\end_layout

\begin_layout Itemize
If in a mathematical operation both of the operands are integers, then the
 result is an integer, except in division where the result is a real.
\end_layout

\end_deeper
\begin_layout Itemize
String
\end_layout

\begin_deeper
\begin_layout Itemize
An UTF-8 character string.
\end_layout

\begin_layout Itemize
From mathematical operations, only addition operation is allowed for strings.
\end_layout

\begin_deeper
\begin_layout Itemize
Addition concatenates two strings, or a string and a numeral into a larger
 string.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Error
\end_layout

\begin_deeper
\begin_layout Itemize
A signal about erroneous execution in a command.
\end_layout

\begin_layout Itemize
Contains the error type and an error message about the nature of error.
\end_layout

\begin_layout Itemize
Can only be created with the 
\begin_inset Formula $Raise$
\end_inset

 keyword and can be catched with the 
\begin_inset Formula $Try$
\end_inset

 and 
\begin_inset Formula $Catch$
\end_inset

 keywords.
\end_layout

\begin_deeper
\begin_layout Itemize
No other operations can be done to the error other than returning or printing
 it
\end_layout

\end_deeper
\begin_layout Itemize
Evaluating an error usually returns from the expression or statement unless
 catched.
\end_layout

\end_deeper
\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Lists are values inside curly brackets and separated by commas.
 For example: 
\begin_inset Formula $\left\{ a,\, b,\, c,\, d,\, e\right\} $
\end_inset

.
 A list can have lists as members, called child-lists.
\end_layout

\begin_layout Subsubsection
List operations
\end_layout

\begin_layout Standard
Operations meant for single values are applied recursively on every list
 member separately when used on lists.
\end_layout

\begin_layout Standard
Numeral lists can be implicitly converted to single values, which evaluates
 as the sum of the list.
\end_layout

\begin_layout Subsubsection
Ranges
\end_layout

\begin_layout Standard
Ranges are flat numeral lists that start from the start value and end on
 the end value, with each consecutive value incrementing or decrementing
 by the step value until the end value is reached.
\end_layout

\begin_layout Standard
Ranges are defined with 
\begin_inset Formula $start,next..end$
\end_inset

 where 
\begin_inset Formula $start$
\end_inset

 is the initial value, 
\begin_inset Formula $end$
\end_inset

 is the last value, or a greater value than the last value, and 
\begin_inset Formula $next$
\end_inset

 is the initial value plus the step value.
 Depending on the step value, the range might not contain the 
\begin_inset Formula $end$
\end_inset

 value, but it will never contain any value with a greater absolute value
 than 
\begin_inset Formula $end$
\end_inset

.
\end_layout

\begin_layout Standard
If the 
\begin_inset Formula $next$
\end_inset

 parameter is omitted, eg.
 
\begin_inset Formula $start..end$
\end_inset

, a step value of +1 or -1 is assumed depending whether 
\begin_inset Formula $start$
\end_inset

 is lesser than 
\begin_inset Formula $end$
\end_inset

 or not.
 If the step value has the wrong sign (eg.
 
\begin_inset Formula $0,4..\left(-12\right)$
\end_inset

) an error is raised.
\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Standard
A variable can hold any value.
 Variable identifiers are recognized by the regexp 
\begin_inset Formula $\left(\,[a-zA-Z]\,|\,\_\,\right)$
\end_inset

, so they can contain only letters and underscores.
\end_layout

\begin_layout Standard
Variables are stored in the environment and to change them you need to use
 statements.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
Functions are repeatable expressions with a zero or more parameters.
 Functions always return a value, which might be an error.
\end_layout

\begin_layout Standard
Parameter is the function's local variable, while argument is the value
 given to the parameter on function call.
 Variable names and function names are in the same namespace, and must be
 unique between eachother.
\end_layout

\begin_layout Subsubsection
Parameters
\end_layout

\begin_layout Standard
By default all variables are in the global namespace, but functions can
 define parameter variables which are always only in the function's namespace.
\end_layout

\begin_layout Standard
If there is a function parameter with the same name as a global variable,
 the parameter hides the global variable.
 No type checking is done to the arguments put into parameters.
\end_layout

\begin_layout Section
Commands
\end_layout

\begin_layout Standard
The Roller interpreter application takes commands as it's input.
 There are two types of commands: expressions and statements.
\end_layout

\begin_layout Standard
Expressions return a value and don't cause side-effects, while statements
 don't return a value and cause side-effects.
 If the command is an expression, it's return value is printed.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
All expressions must return a value, which can be an error.
\end_layout

\begin_layout Standard
If error was returned it has the information about where it was raised and
 it's callstack.
\end_layout

\begin_layout Subsubsection
Expression types
\end_layout

\begin_layout Itemize
Value expression
\end_layout

\begin_deeper
\begin_layout Itemize
This constructs a value
\end_layout

\begin_layout Itemize
Value can be a single value or a list.
\end_layout

\begin_layout Itemize
The value types are defined earlier in the part 1
\end_layout

\end_deeper
\begin_layout Itemize
Dice expressions
\end_layout

\begin_deeper
\begin_layout Itemize
An expression that represents dice throw with multiple similar die.
\end_layout

\begin_layout Itemize
Uses the dice notation, so 
\begin_inset Formula $N\mbox{d}M$
\end_inset

 means throw N amount of M sided die, where N and M are integers or integer
 expressions.
 If the parameters are not present the defaults are used.
\end_layout

\begin_deeper
\begin_layout Itemize
By default the amount is 1 and the sides are 6, so 
\begin_inset Formula $\mbox{d}$
\end_inset

 equals to 
\begin_inset Formula $1\mbox{d}6$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
If the sides parameter is a list, then each of the dice face is one of the
 list members.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $1\mbox{d}\left\{ "heads",\,"tails"\right\} $
\end_inset

 either gives the string 
\begin_inset Formula $"heads"$
\end_inset

 or the string 
\begin_inset Formula $"tails"$
\end_inset

 as the result.
\end_layout

\end_deeper
\begin_layout Itemize
If the amount parameter is a list of integers, then the expression returns
 a list where each list member is a list of that many dice throws as the
 corresponding parameter integer.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left\{ 2,\,4,\,3\right\} \mbox{d}6$
\end_inset

 is equivalent to 
\begin_inset Formula $\left\{ 2\mbox{d}6,\,4\mbox{d}6,\,3\mbox{d}6\right\} $
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Mathemathical operators
\end_layout

\begin_deeper
\begin_layout Itemize
All mathematical operators are infix, except the negation operator.
\end_layout

\begin_layout Itemize
All operators behave as expected between single values (scalars).
\end_layout

\begin_layout Itemize
If one of the operands is a list and the another is a single value, then
 the operation is applied to the every element on the list element-wise.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $a+\left\{ b,\, c\right\} \rightarrow\left\{ a+b,\, a+c\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If both of the operands are lists then the operator is applied between each
 element.
 If another list is longer than another, then the remaining elements are
 ignored.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left\{ a,\, b,\, c\right\} *\left\{ d,\, e\right\} \rightarrow\left\{ a*d,\, b*e\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Comparison operators
\end_layout

\begin_deeper
\begin_layout Itemize
All comparison operators are infix.
\end_layout

\begin_layout Itemize
Operates only between scalar numeral values.
\end_layout

\begin_layout Itemize
Evaluates as 
\begin_inset Formula $1$
\end_inset

 if the comparison holds true and evaluates as 
\begin_inset Formula $0$
\end_inset

 if it doesn't hold true.
\end_layout

\end_deeper
\begin_layout Itemize
Logical connectives
\end_layout

\begin_deeper
\begin_layout Itemize
Logical connectives connect different filtering predicates or expressions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $0$
\end_inset

 is considered as false, anything else is considered as true.
\end_layout

\begin_deeper
\begin_layout Itemize
If a real value is really close to zero, treat it as zero to get rid of
 floating point errors.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Keyword expressions
\end_layout

\begin_deeper
\begin_layout Itemize
All keywords start with a capital letter followed by non-capital or capital
 letters.
\end_layout

\begin_layout Itemize
All keyword expressions consist of a keyword and the parameters.
 The keyword is always before the parameters.
\end_layout

\begin_layout Itemize
Unlike functions, keyword expression's arguments are not surrounded by parenthes
es.
\end_layout

\begin_layout Itemize
The different keywords and their functions are defined in 2.1.2.
\end_layout

\begin_deeper
\begin_layout Itemize
Some common keyword expressions are explained below.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If expression
\end_layout

\begin_deeper
\begin_layout Itemize
Syntax: 
\begin_inset Formula $If\: a\: Then\: b\: Else\: c$
\end_inset


\end_layout

\begin_layout Itemize
The else part is required since this is an expression and has to return
 a value.
\end_layout

\begin_layout Itemize
Returns 
\begin_inset Formula $b$
\end_inset

 if the condition expression 
\begin_inset Formula $a$
\end_inset

 is not a scalar 
\begin_inset Formula $0$
\end_inset

 or an empty list (
\begin_inset Formula $\{\}$
\end_inset

), otherwise returns expression 
\begin_inset Formula $c$
\end_inset

.
\end_layout

\begin_layout Itemize
Can be used with the filtering expressions.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $If\: foo[>3]\: Then\:1\mbox{d}20+2\: Else\:3\mbox{d}6$
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $If\: a[=1]\, Then\,"\mbox{a is one}"\, Else\: If\: a[=2]\: Then\,"\mbox{a is two}"\, Else\,"\mbox{a is not one or two}"$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Switch/Case expression
\end_layout

\begin_deeper
\begin_layout Itemize
Syntax: 
\begin_inset Formula $Switch\, a\: Case\, value\,:\, expression\ldots Default:\, c$
\end_inset


\end_layout

\begin_layout Itemize
The default part is required since this is an expression and has to return
 a value.
\end_layout

\begin_layout Itemize
Compares the value of the expression 
\begin_inset Formula $a$
\end_inset

 against all of the 
\begin_inset Formula $value$
\end_inset

 parts of the case-parts and the 
\begin_inset Formula $expression$
\end_inset

 of the first matching case part is returned.
\end_layout

\begin_deeper
\begin_layout Itemize
If nothing matches the default part is returned.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Namespace calls
\end_layout

\begin_deeper
\begin_layout Itemize
To use the value of a variable write it's name.
 If there is no variable with that name an error is given.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $foo+1$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To call a function write it's name, followed by it's arguments, if any,
 in parenthesis.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $foo(1,6)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
List filtering expression
\end_layout

\begin_deeper
\begin_layout Itemize
The lists can be filtered with the filtering expression.
\end_layout

\begin_layout Itemize
The filtering expression consists of the filtered expression and the predicate
 in square brackets.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $Count\,8\mbox{d}6[>=5]$
\end_inset

 counts all the dice throws that were five or six.
\end_layout

\end_deeper
\begin_layout Itemize
Returns a list of the members that fit the for each of the predicates in
 the list.
\end_layout

\begin_layout Itemize
Filtering considers each list member separately, so normally filtering is
 not done to the child list members.
\end_layout

\begin_deeper
\begin_layout Itemize
There is however a list predicate that matches child lists and can be used
 to match child list members.
\end_layout

\end_deeper
\begin_layout Itemize
The different predicates are defined in the part 3
\end_layout

\end_deeper
\begin_layout Subsubsection
Different operator and keyword expressions
\end_layout

\begin_layout Itemize
Mathemathical operators (precedence is as expected)
\end_layout

\begin_deeper
\begin_layout Itemize
Addition/String concatenation (
\begin_inset Formula $a+b$
\end_inset

) 
\end_layout

\begin_layout Itemize
Substraction (
\begin_inset Formula $a-b$
\end_inset

)
\end_layout

\begin_layout Itemize
Multiplication (
\begin_inset Formula $a*b$
\end_inset

)
\end_layout

\begin_layout Itemize
Division (
\begin_inset Formula $a/b$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Result is a scalar real numeral if the operands were scalar integer or real
 numerals.
\end_layout

\end_deeper
\begin_layout Itemize
Exponent (
\begin_inset Formula $a\mathcircumflex b$
\end_inset

)
\end_layout

\begin_layout Itemize
Negation (
\begin_inset Formula $-a$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Note: 
\begin_inset Formula $-a\mathcircumflex b$
\end_inset

 means 
\begin_inset Formula $-\left(a\mathcircumflex b\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Comparison operators
\end_layout

\begin_deeper
\begin_layout Itemize
Equivalence (
\begin_inset Formula $=$
\end_inset

)
\end_layout

\begin_layout Itemize
Inequivalence (
\begin_inset Formula $!=$
\end_inset

)
\end_layout

\begin_layout Itemize
Greater than (
\begin_inset Formula $>$
\end_inset

)
\end_layout

\begin_layout Itemize
Less than (
\begin_inset Formula $<$
\end_inset

)
\end_layout

\begin_layout Itemize
Greater or equal (
\begin_inset Formula $>=$
\end_inset

)
\end_layout

\begin_layout Itemize
Less or equal (
\begin_inset Formula $<=$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Logical connectives
\end_layout

\begin_deeper
\begin_layout Itemize
Available connectives are (notice that false is equal to numeral 0 and true
 is anything else):
\end_layout

\begin_deeper
\begin_layout Itemize
Conjunction/and, 
\begin_inset Formula $a\,\&\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff (if and only if) both of the operand predicates (
\begin_inset Formula $a$
\end_inset

, 
\series bold

\begin_inset Formula $b$
\end_inset

)
\series default
 are true.
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction/or, 
\begin_inset Formula $a\,|\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff any of the operands are true.
\end_layout

\end_deeper
\begin_layout Itemize
Exclusive disjunction/xor, 
\begin_inset Formula $a\,\mathcircumflex\mathcircumflex\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff one of the operands are different.
\end_layout

\end_deeper
\begin_layout Itemize
Negation/not, 
\begin_inset Formula $!a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined true iff the operand is false.
\end_layout

\begin_layout Itemize
Has high precedence
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Keyword expressions
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Length\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Gives the length of a list
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Sum\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Gives the sum of a list
\end_layout

\begin_layout Itemize
Only defined for lists with numeral values
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Concat\, a\, separator$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Concatenates all of the items of a list into a string with the 
\begin_inset Formula $separator$
\end_inset

 string inserted between them
\end_layout

\begin_layout Itemize
Defined for all of the lists
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Mean\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\begin_layout Itemize
Returns the mean value of a numeral list
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Sqrt\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Returns the square root of 
\begin_inset Formula $a$
\end_inset

 recursively
\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Formula $Root\: n\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only defined on numeral values
\end_layout

\begin_layout Itemize
Returns the 
\begin_inset Formula $n$
\end_inset

:th root of 
\begin_inset Formula $a$
\end_inset

 recursively
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $n$
\end_inset

 is a list return the roots for all it's lists recursively
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Repeat\: n\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Repeats the 
\begin_inset Formula $a$
\end_inset

 expression 
\begin_inset Formula $n$
\end_inset

 times and returns a list of the 
\begin_inset Formula $a$
\end_inset

's value for each repetition.
\end_layout

\begin_layout Itemize
The first parameter must be an integer or an integer list.
\end_layout

\begin_layout Itemize
If the first parameter is an integer list then the repeat is done for each
 of it's members recursively.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $Repeat\:\left\{ 3,\,2\right\} \:1\mbox{d}20$
\end_inset

 is equivalent to 
\begin_inset Formula $\left\{ Repeat\:3\:1\mbox{d}20,\, Repeat\:2\:1\mbox{d}20\right\} $
\end_inset

.
 It is also equivalent to 
\begin_inset Formula $\left\{ 3,\,2\right\} \mbox{d}20$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Formula $Acc\: function\: sequence$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Accumulates the 
\begin_inset Formula $function$
\end_inset

 over the 
\begin_inset Formula $sequence$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $function$
\end_inset

 must have exactly two parameters.
\end_layout

\begin_layout Itemize
The first argument to the function is the accumulated value.
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $Acc\: add\:\left\{ 1,2,4,3\right\} $
\end_inset

, where 
\begin_inset Formula $add(a,\, b)=a+b$
\end_inset

, is equivalent to 
\begin_inset Formula $Sum\,\left\{ 1,2,4,3\right\} $
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $Acc\, f\,\left\{ 1,2,3,4\right\} $
\end_inset

, where 
\begin_inset Formula $f\left(a,\, b\right)=-a-b$
\end_inset

, is equivalent to 
\begin_inset Formula $-\left(-\left(-1-2\right)-3\right)-4=-4$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Flatten\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Converts all the child lists of 
\begin_inset Formula $a$
\end_inset

 into single values
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $Flatten\,\{a,\,\{b,\,\{c,\, d\}\},\,\{e\}\}\rightarrow\{a,\, b+c+d,\, e\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToFlat\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Flattens the 
\begin_inset Formula $a$
\end_inset

 list so that it contains no child lists
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $Flatten\,\{a,\,\{b,\,\{c,\, d\}\},\,\{e\}\}\rightarrow\{a,\, b,\, c,\, d,\, e\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToString\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Returns a string representation of 
\begin_inset Formula $a$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToNumeral\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $a$
\end_inset

 is a string this returns it's numeral representation.
 If the string doesn't contain a numeral (integer or floating point) this
 returns an error
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $a$
\end_inset

 is a numeral list this returns it's sum
\end_layout

\begin_deeper
\begin_layout Itemize
Otherwise returns an error
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Formula $ToList\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Defined for strings
\end_layout

\begin_layout Itemize
Converts the string 
\begin_inset Formula $a$
\end_inset

 to a list of letters
\end_layout

\begin_layout Itemize
The letters are single character strings
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Raise\: a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Returns an error with 
\begin_inset Formula $a$
\end_inset

 as it's error message.
\end_layout

\begin_layout Itemize
Evaluating this effectively terminates the expression
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Try\: a\: Catch\,:\, b$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Evaluates 
\begin_inset Formula $a$
\end_inset

 and if it returns an error returns 
\begin_inset Formula $b$
\end_inset

, otherwise returns the value of 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Statements
\end_layout

\begin_layout Standard
Statements have side-effects, which means that they change the state of
 the environment, more specifically the namespace.
\end_layout

\begin_layout Standard
Statements have higher precedence than the expressions.
\end_layout

\begin_layout Standard
Instead of returning errors, the statements raise errors.
 The effect is the same though, the error is printed to the command line.
\end_layout

\begin_layout Subsubsection
Variable statements
\end_layout

\begin_layout Itemize
Variable assignment, 
\begin_inset Formula $name=expression$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Creates or replaces a variable with the of 
\begin_inset Formula $name$
\end_inset

 with the evaluated value of 
\begin_inset Formula $expression$
\end_inset


\end_layout

\begin_layout Itemize
Can't be mixed with the equality comparison expression because statements
 have higher precedence than expressions.
\end_layout

\end_deeper
\begin_layout Itemize
Operation and assignment, 
\begin_inset Formula $+=$
\end_inset

, 
\begin_inset Formula $-=$
\end_inset

, 
\begin_inset Formula $*=$
\end_inset

, 
\begin_inset Formula $/=$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does the operation with the variable and the expression as operands and
 places the result into the variable.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $foo+=4$
\end_inset

 is equivalent to 
\begin_inset Formula $foo=foo+4$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If the variable doesn't exist this raises an 
\begin_inset Formula $Undeclared\, Variable$
\end_inset

 error
\end_layout

\end_deeper
\begin_layout Itemize
Delete statement, 
\begin_inset Formula $Delete\: name$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Deletes the variable or function 
\begin_inset Formula $name$
\end_inset

.
\end_layout

\begin_layout Itemize
If the operand doesn't exist this raises an 
\begin_inset Formula $Undeclared\, Name$
\end_inset

 error
\end_layout

\end_deeper
\begin_layout Itemize
Try and catch statement, 
\begin_inset Formula $Try\: a\: Catch\,:\, cmd$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If the statement 
\begin_inset Formula $a$
\end_inset

 raises any error, then the command 
\begin_inset Formula $cmd$
\end_inset

 is executed, which can be an expression or statement.
\end_layout

\begin_layout Itemize
Works like the try and catch expression, except on statements.
\end_layout

\begin_layout Itemize
Doesn't return a value, but if the 
\begin_inset Formula $cmd$
\end_inset

 is an expression then it's value is printed as normal.
\end_layout

\end_deeper
\begin_layout Subsubsection
Function definition
\end_layout

\begin_layout Standard
Functions are defined like: 
\begin_inset Formula $name()=expression$
\end_inset

 or 
\begin_inset Formula $name(parameterList)=expression$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $parameterList$
\end_inset

 is a comma separated list of parameters, which are variables local to the
 function and assigned values on the function call.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $expression$
\end_inset

 is evaluated when the function is called.
\end_layout

\begin_layout Standard
Function and variable names should be unique and defining a function or
 variable with the same name as any existing function or variable raises
 an error.
\end_layout

\begin_layout Section
Predicates
\end_layout

\begin_layout Standard
Predicates define which values are passed through when filtering a list.
\end_layout

\begin_layout Standard
If there are multiple predicates, separated by commas, the filtering branches
 and it is done for all of the predicates and returned in a list.
\end_layout

\begin_layout Standard
List of the precedence levels different predicates have:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicate precedence level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 1, lowest precedence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical connectives, except negation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparison predicates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 3, highest precedence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type predicates, indexing predicates, negation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Logical connectives
\end_layout

\begin_layout Standard
Logical connectives connect different predicates.
\end_layout

\begin_layout Standard
The connectives are defined earlier in the expressions.
\end_layout

\begin_layout Subsection
Comparison predicates
\end_layout

\begin_layout Itemize
Equality, 
\begin_inset Formula $=a$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Inequality can be achieved by combining the equality and negation predicates.
\end_layout

\end_deeper
\begin_layout Itemize
Comparison, 
\begin_inset Formula $<a$
\end_inset

, 
\begin_inset Formula $>a$
\end_inset

, 
\begin_inset Formula $<=a$
\end_inset

, 
\begin_inset Formula $>=a$
\end_inset


\end_layout

\begin_layout Subsection
Type predicates
\end_layout

\begin_layout Standard
These predicates hold true only for certain type of values
\end_layout

\begin_layout Itemize
Integer predicate, 
\begin_inset Formula $\#$
\end_inset


\end_layout

\begin_layout Itemize
Real predicate, 
\begin_inset Formula $\%$
\end_inset


\end_layout

\begin_layout Itemize
String predicate, 
\begin_inset Formula $\$$
\end_inset


\end_layout

\begin_layout Itemize
List predicate, 
\begin_inset Formula $\{\}$
\end_inset

, 
\begin_inset Formula $\{Predicate\}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Matches child lists
\end_layout

\begin_layout Itemize
The empty list predicate 
\begin_inset Formula $\{\}$
\end_inset

 matches any list.
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $Predicate$
\end_inset

 is almost any predicate that tells what kind of list we match.
 It must hold true for all of the members of the child list.
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Formula $Predicate$
\end_inset

 can't contain single values because that would be mixed with list indexing
 predicate (3.4)
\end_layout

\end_deeper
\begin_layout Itemize
Examples:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\{\#\}$
\end_inset

 matches integer lists
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{\#\,|\,\%\}$
\end_inset

 matches lists with integer and/or real values (numerals)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{\,!\{\}\,\}$
\end_inset

 matches lists that don't have any list members
\end_layout

\begin_layout Itemize
\begin_inset Formula $\{<5\}$
\end_inset

 matches lists with only numeral variables that are smaller than five
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Indexing predicates
\end_layout

\begin_layout Standard
These predicates hold true only for a certain index or range of any list.
 They are normal expressions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Value$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Value$
\end_inset

 is not a list.
\end_layout

\begin_layout Itemize
Holds true only for the list member that is at the index 
\begin_inset Formula $Value$
\end_inset

.
\end_layout

\begin_layout Itemize
For normal lists the indexing starts from one.
 This is because dice ranges start from one as well.
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $\{4,2,3\}[1]\rightarrow\{4\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $List$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Holds true for the values whose indexes are in the 
\begin_inset Formula $List$
\end_inset

.
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $\{4,2,3\}[\{1,2\}]\rightarrow\{4,2\}$
\end_inset

, whereas 
\begin_inset Formula $\{4,2,3\}[1,2]\rightarrow\{\{4\},\{2\}\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Errors
\end_layout

\begin_layout Standard
An error is returned (expressions) or raised (statements) when the program
 runs into an erroneous situation and can't continue.
 If an error happens during a statetement, the program state shouldn't be
 changed by that statement.
\end_layout

\begin_layout Standard
Information of the type of the error with more info and suggestions should
 be given to the user.
 The error messages should be given in a human-readable form.
\end_layout

\begin_layout Standard
Suggested error message format is: 
\begin_inset Quotes eld
\end_inset

([Error number]) [Error name]: [Error message], at 
\begin_inset Quotes eld
\end_inset

[Error location]
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes erd
\end_inset

, for example 
\begin_inset Quotes eld
\end_inset

(11) Arithmetic error: division by zero, at 
\begin_inset Quotes eld
\end_inset

1/x
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Parse error
\end_layout

\begin_layout Standard
If the written input doesn't follow the semantic syntax of the language
 an parse error should be created.
 Additional information could be what position the error was encountered.
\end_layout

\begin_layout Standard
The details and different types of these errors are dependent on the implementat
ion of the parser.
\end_layout

\begin_layout Standard
Various possible parse errors:
\end_layout

\begin_layout Itemize
Invalid token error
\end_layout

\begin_deeper
\begin_layout Itemize
When the lexer finds an invalid token
\end_layout

\begin_layout Itemize
Example: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Quotes eld
\end_inset

Invalid token error: letters in an integer value, at 
\begin_inset Quotes eld
\end_inset

41a3
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\begin_inset Quotes eld
\end_inset

Invalid token error: invalid character, at 
\begin_inset Quotes eld
\end_inset

böö
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Semantic error
\end_layout

\begin_deeper
\begin_layout Itemize
When the semantic analyzer finds an invalid structure
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Quotes eld
\end_inset

Semantic error: unclosed parenthesis, at 
\begin_inset Quotes eld
\end_inset

(1+2
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Execution error
\end_layout

\begin_layout Standard
Error that was encountered during the execution of a command.
\end_layout

\begin_layout Standard
Various possible errors:
\end_layout

\begin_layout Itemize
Arithmetic error
\end_layout

\begin_deeper
\begin_layout Itemize
Division by zero
\end_layout

\begin_layout Itemize
Use of special floating point values, like NaN or infinity inapproriately
\end_layout

\end_deeper
\begin_layout Itemize
Invalid type error
\end_layout

\begin_deeper
\begin_layout Itemize
Use of wrong type
\end_layout

\end_deeper
\end_body
\end_document
